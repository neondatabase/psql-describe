let Ie=!1,_a=0;const r=null,da=100,ua="E",Ea=0,Fe=0,ve=1,X=0,Me=2,Ae=5,pe=0,Ue=4,
ma=6,Ge=0,Na=1,Sa="b",Aa="i",Ta="a",Oa="e",Ra="r",ya="S",ba="f",La="T",Da="n",ha="\
a",wa="d",Ha="s",Z="r",ce="i",Ca="S",Te="t",Oe="v",G="m",qe="c",ee="f",$="p",ae="\
I",Ia=20,Fa=21,va=23,ka=26,Wa=28,xa=29,Pa=5069,Ma=700,Ua=701,qa=790,Ja=1700;let O,
p,Q;const Ya=`Help
  \\? [commands]          show help on backslash commands

Informational
  (options: S = show system objects, + = additional detail)
  \\d[S+]                 list tables, views, and sequences
  \\d[S+]  NAME           describe table, view, sequence, or index
  \\da[S]  [PATTERN]      list aggregates
  \\dA[+]  [PATTERN]      list access methods
  \\dAc[+] [AMPTRN [TYPEPTRN]]  list operator classes
  \\dAf[+] [AMPTRN [TYPEPTRN]]  list operator families
  \\dAo[+] [AMPTRN [OPFPTRN]]   list operators of operator families
  \\dAp[+] [AMPTRN [OPFPTRN]]   list support functions of operator families
  \\db[+]  [PATTERN]      list tablespaces
  \\dc[S+] [PATTERN]      list conversions
  \\dconfig[+] [PATTERN]  list configuration parameters
  \\dC[+]  [PATTERN]      list casts
  \\dd[S]  [PATTERN]      show object descriptions not displayed elsewhere
  \\dD[S+] [PATTERN]      list domains
  \\ddp    [PATTERN]      list default privileges
  \\dE[S+] [PATTERN]      list foreign tables
  \\des[+] [PATTERN]      list foreign servers
  \\det[+] [PATTERN]      list foreign tables
  \\deu[+] [PATTERN]      list user mappings
  \\dew[+] [PATTERN]      list foreign-data wrappers
  \\df[anptw][S+] [FUNCPTRN [TYPEPTRN ...]]
                         list [only agg/normal/procedure/trigger/window] functio\
ns
  \\dF[+]  [PATTERN]      list text search configurations
  \\dFd[+] [PATTERN]      list text search dictionaries
  \\dFp[+] [PATTERN]      list text search parsers
  \\dFt[+] [PATTERN]      list text search templates
  \\dg[S+] [PATTERN]      list roles
  \\di[S+] [PATTERN]      list indexes
  \\dl[+]                 list large objects, same as \\lo_list
  \\dL[S+] [PATTERN]      list procedural languages
  \\dm[S+] [PATTERN]      list materialized views
  \\dn[S+] [PATTERN]      list schemas
  \\do[S+] [OPPTRN [TYPEPTRN [TYPEPTRN]]]
                         list operators
  \\dO[S+] [PATTERN]      list collations
  \\dp[S]  [PATTERN]      list table, view, and sequence access privileges
  \\dP[itn+] [PATTERN]    list [only index/table] partitioned relations [n=nested\
]
  \\drds [ROLEPTRN [DBPTRN]] list per-database role settings
  \\drg[S] [PATTERN]      list role grants
  \\dRp[+] [PATTERN]      list replication publications
  \\dRs[+] [PATTERN]      list replication subscriptions
  \\ds[S+] [PATTERN]      list sequences
  \\dt[S+] [PATTERN]      list tables
  \\dT[S+] [PATTERN]      list data types
  \\du[S+] [PATTERN]      list roles
  \\dv[S+] [PATTERN]      list views
  \\dx[+]  [PATTERN]      list extensions
  \\dX     [PATTERN]      list extended statistics
  \\dy[+]  [PATTERN]      list event triggers
  \\l[+]   [PATTERN]      list databases
  \\lo_list[+]            list large objects
  \\sf[+]  FUNCNAME       show a function's definition
  \\sv[+]  VIEWNAME       show a view's definition
  \\z[S]   [PATTERN]      same as \\dp
`;export async function describe(t,s,e,n,l=!1,a=null,i=1){const E=t.types.getTypeParser;
if(t.types.getTypeParser=()=>N=>N,a==null){const N=await n("SHOW server_version_\
num");a=parseInt(N.rows[0][0],10)}Q=[],p={sversion:a,db:{dbName:e,sversion:a,std_strings:i,
status:Ge,encoding:ma},popt:{topt:{default_footer:!0},nullPrint:""}},O=N=>(l&&Q.
push(`/******** QUERY *********/
${N}
/************************/`),n(N));const f=s.match(/^\\([?dzsl]\S*)(.*)/);if(f){
let[,N,c]=f;if(N=N.replace(/^lo_list/,"dl"),N=N.replace(/^z/,"dp"),N[0]==="?")Q.
push(Ya);else{const A=[c,0];try{await(N[0]==="d"?ot(A,!0,N):N[0]==="s"?N[1]==="f"||
N[1]==="v"?at(A,!0,N,N[1]==="f"):X:rt(A,!0,N))==X&&Q.push(`invalid command \\${N}`);
let b,y=[];for(;b=fe(A,pe,r,!0);)y.push(Y('\\%s: extra argument "%s" ignored',N,
b));y.length>0&&Q.push(y.join(`
`))}catch(S){Q.push("ERROR:  "+S.message)}}}else Q.push(`unsupported command: ${s}`);
return t.types.getTypeParser=E,Q}export function describeDataToString(t){return t.
map(s=>typeof s=="string"?s:ja(s)).join(`

`)}export function describeDataToHtml(t){return t.map(s=>typeof s=="string"?`<p>${ie(
s,!0)}</p>`:za(s)).join(`

`)}function Ke(t,s,e,n="",l=""){const a=Math.max(0,s-te(t));return e==="r"?n+" ".
repeat(a)+t+l:e==="c"?n+" ".repeat(Math.floor(a/2))+t+" ".repeat(Math.ceil(a/2))+
l:n+t+" ".repeat(a)+l}function Xe(t,s){let e=0;const n=t.length,l=[];for(;e<n;)l.
push(t.slice(e,e+=s));return l}function Ba(t){let s=-1,e=0,n=1,l=0;for(;(s=t.indexOf(
`
`,s+1))!==-1;)s-e>l&&(l=s-e),e=s+1,n++;return t.length-e>l&&(l=t.length-e),{count:n,
longest:l}}function ie(t,s){return t=t.replace(/[<>&'"]/g,e=>({"<":"&lt;",">":"&\
gt;","&":"&amp;","'":"&apos;",'"':"&quot;"})[e]),s&&(t=t.replace(/ /g,"&nbsp;").
replace(/\n/g,"<br />")),t}function ja(t,s){const{ncolumns:e,nrows:n,aligns:l}=t,
a=[...t.headers,...t.cells].map(Ba),{colWidths:i,rowHeights:E}=a.reduce((y,H,M)=>{
const w=Math.floor(M/t.ncolumns),j=M%t.ncolumns;return H.longest>y.colWidths[j]&&
(y.colWidths[j]=H.longest),H.count>y.rowHeights[w]&&(y.rowHeights[w]=H.count),y},
{colWidths:new Array(e).fill(0),rowHeights:new Array(n+1).fill(1)}),f=i.reduce((y,H)=>y+
H,0)+e*2+(e-1),N=Ke(t.title,f,"c"),c=[t.headers,null,...Xe(t.cells,e)],A=c.map((y,H)=>{
if(H===1)return t.headers.map((w,j)=>"-".repeat(i[j%e]+2)).join("+");H>1&&H--;const M=y.
map(w=>w.split(`
`));return new Array(E[H]).fill("").map((w,j)=>M.map((ne,se)=>Ke(ne[j]??"",i[se],
H===0?"c":l[se]," ",ne[j+1]===void 0?" ":"+")).join("|")).join(`
`)}).join(`
`),S=t.footers?`
`+t.footers.join(`
`):t.opt.default_footer?`
(${n} row${n===1?"":"s"})`:"";let b=`${N}
${A}${S}`;return s&&(b=ie(b)),b}function za(t){let s=`<table><tr><th valign="top\
" style="text-align: center;" colspan="${t.ncolumns}">${ie(t.title)}</th></tr><t\
r>`;for(let e of t.headers)s+=`<th valign="top" style="text-align: center;">${ie(
e)}</th>`;s+="</tr>";for(let e of Xe(t.cells,t.ncolumns))s+="<tr>"+e.map((n,l)=>`\
<td valign="top" style="text-align: ${t.aligns[l]==="c"?"center":t.aligns[l]==="\
r"?"right":"left"}">${ie(n).replace(/\n/g,"<br>")}</td>`).join(`
`)+"</tr>";return s+="</table>",t.footers?t.footers.length>1&&t.footers.some(e=>/^\s/.
test(e))?s+="<dl>"+t.footers.map(e=>/^\s/.test(e)?`<dd>${ie(e.trim(),!0)}</dd>`:
`<dt>${ie(e,!0)}</dt>`).join("")+"</dl>":s+=t.footers.map(e=>`<p>${ie(e,!0)}</p>`).
join(""):t.opt.default_footer&&(s+=`<p>(${t.nrows} row${t.nrows===1?"":"s"})</p>`),
s}function tn(t){return t}function q(t,s){return ke(t,s)}function ke(t,s){const e=t.
indexOf(s);return e===-1?r:e}function te(t){return t.length}function D(t,s){return de(
t,s,1/0)}function de(t,s,e){if(typeof t!="string"||typeof s!="string")throw new Error(
"Not a string");return t.length>e&&(t=t.slice(0,e)),s.length>e&&(s=s.slice(0,e)),
t<s?-1:t>s?1:0}function $a(t,s){const e=te(t);for(let n=0;n<e;n++)if(s.indexOf(t[n])===
-1)return n;return e}function Ze(t){return parseInt(t,10)}function Je(t){return parseInt(
t,10)}function nn(t){return t}function ea(t){return t===" "||t==="	"||t===`
`||t==="\r"}function Qa(t){return t==='"'||t==="'"}function aa(t){return t?t.dbName:
r}function Re(t){return!t||t.status===Na?0:t.sversion}function ta(t){return!t||t.
status!=Ge?-1:t.client_encoding}function v(t){return t.rowCount}function na(t){return t.
fields.length}function sa(t,s){return t.fields[s].name}function Va(t,s){return t.
fields[s].dataTypeID}function B(t,s,e){return t.rows[s][e]===null?1:0}function _(t,s,e){
const n=t.rows[s][e];return String(n===null?"":n)}function ge(t,s){let e,n,l,a,i;
if(!t||s==r||s[0]==r)return-1;for(e=!1,l="",n=0,i=te(s);n<i;n++){let E=s[n];e?E==
'"'?s[n+1]=='"'?(l+='"',n++):e=!1:l+=E:E=='"'?e=!0:(E=je(E),l+=E)}for(a=0,i=na(t);a<
i;a++)if(D(l,sa(t,a))==0)return a;return-1}function la(t,s,e){return s}function re(t){
return 0}function sn(t){return t}function oe(t,s,e,n){return t>=1e5?s?e=Y("%d.%d",
Math.floor(t/1e4),t%1e4):e=Y("%d",t/1e4):s?e=Y("%d.%d.%d",Math.floor(t/1e4),Math.
floor(t/100)%100,t%100):e=Y("%d.%d",Math.floor(t/1e4),Math.floor(t/100)%100),e}function fe(t,s,e,n){
if(s!==pe&&s!==Ue)throw new Error(`scan type ${s} not implemented`);if(e!==r)throw new Error(
"cannot return quote type");const l=[],a=n?/^(.*);*$/:/^(.*)$/;let i;for(;;){if(i=
t[0][t[1]],i==r)return r;if(!ea(i))break;t[1]++}if(s===Ue)return t[0].slice(t[1],
t[1]=t[0].length);let E="";for(;;){if(i=t[0][t[1]++],i==r)return l.length>0?r:E.
match(a)[1];if(Qa(i))i===l[l.length-1]?l.pop():l.push(i),i==='"'&&(E+=i);else{if(l.
length===0&&ea(i))return E.match(a)[1];E+=i}}}function R(t){t.data="",t.len=0}function Ye(t){
R(t)}function o(t,s){t.data+=s,t.len=t.data.length}function Y(t,...s){let e="",n=0,
l=0,a;for(;(a=t.indexOf("%",l))!==-1;){let i=0,E=!1;e+=t.slice(l,a),l=a+1;let f=t[l++];
if(f==="%"&&(e+="%"),f==="*"&&(i=parseInt(s[n++],10),f=t[l++]),f==="-"&&(E=!0,f=
t[l++]),f>="0"&&f<="9"&&(i=parseInt(f,10),f=t[l++]),f==="s"||f==="c"||f==="d"||f===
"u"){const N=String(s[n++]),c=i-N.length;E===!1&&c>0&&(e+=" ".repeat(c)),e+=N,E===
!0&&c>0&&(e+=" ".repeat(c))}}return e+=t.slice(l),e}function d(t,s,...e){R(t),u(
t,s,...e)}function u(t,s,...e){const n=Y(s,...e);o(t,n)}function k(t,...s){Q.push(
Y(t,...s))}function ln(t,...s){Q.push(Y(t,...s))}function h(t,s,e,n,l,a,i,E,f,N){
let c={},A={},S;if(R(c),S=ia(p.db,t,s,e,n,l,a,i,E,c,A),A=A.value,f&&(f.value=S),
A>=N)return k("improper qualified name (too many dotted names): %s",s),!1;if(N>1&&
A==N-1){if(aa(p.db)==r)return k("You are currently not connected to a database."),
!1;if(D(aa(p.db),c.data)!=0)return k("cross-database references are not implemen\
ted: %s",s),!1}return!0}function ia(t,s,e,n,l,a,i,E,f,N,c){let A={},S={},b=!1;return c||
(c={}),c.value=0,e==r?(f&&(o(s,n?"  AND ":"WHERE "),n=!0,b=!0,u(s,`%s
`,f)),b):(R(A),R(S),Xa(ta(t),a?N:r,a?A:r,S,e,l,!0,c),i&&S.len>2&&D(S.data,"^(.*)\
$")!=0&&(o(s,n?"  AND ":"WHERE "),n=!0,b=!0,E?(u(s,"(%s OPERATOR(pg_catalog.~) ",
i),ue(s,S.data,t),Re(t)>=12e4&&o(s," COLLATE pg_catalog.default"),u(s,`
        OR %s OPERATOR(pg_catalog.~) `,E),ue(s,S.data,t),Re(t)>=12e4&&o(s," COLL\
ATE pg_catalog.default"),o(s,`)
`)):(u(s,"%s OPERATOR(pg_catalog.~) ",i),ue(s,S.data,t),Re(t)>=12e4&&o(s," COLLA\
TE pg_catalog.default"),x(s,`
`))),a&&A.len>2?D(A.data,"^(.*)$")!=0&&a&&(o(s,n?"  AND ":"WHERE "),n=!0,b=!0,u(
s,"%s OPERATOR(pg_catalog.~) ",a),ue(s,A.data,t),Re(t)>=12e4&&o(s," COLLATE pg_c\
atalog.default"),x(s,`
`)):f&&(o(s,n?"  AND ":"WHERE "),n=!0,b=!0,u(s,`%s
`,f)),b)}function x(t,s){t.data+=s,t.len++}function Be(t,s,e,n){const l=s.replace(
n?/[']/g:/['\\]/g,"\\$&");t.data+="'"+l+"'",t.len=t.data.length}function ue(t,s,e){
if(q(s,"\\")!=r&&Re(e)>=80100){t.len>0&&t.data[t.len-1]!=" "&&x(t," "),x(t,ua),Be(
t,s,ta(e),!1);return}Be(t,s,e.encoding,e.std_strings)}function Ee(t){if(!t)throw new Error(
`Assertion failed (value: ${t})`)}function Ga(t){const s=t.charCodeAt(0);return s>=
65&&s<=90}function J(t){return t.length}function je(t){return t.toLowerCase()}function Ka(t,s){
return D(t.toLowerCase(),s.toLowerCase())}function Xa(t,s,e,n,l,a,i,E){let f=[{},
{},{}],N=0,c={},A={},S={},b,y,H;Ee(l),Ee(n),Ee(!s||e),Ee(E),E.value=0,b=!1,H=l,s?
S=2:e?S=1:S=0,A=f[N],i?(y=!0,R(c)):y=!1,R(A),o(A,"^(");let M=0,w;for(;(w=H[M])!=
r;)w=='"'?(b&&H[M+1]=='"'?(x(A,'"'),y&&x(c,'"'),M++):b=!b,M++):!b&&Ga(w)?(x(A,je(
w)),y&&x(c,je(w)),M++):!b&&w=="*"?(o(A,".*"),y&&x(c,"*"),M++):!b&&w=="?"?(x(A,"."),
y&&x(c,"?"),M++):!b&&w=="."?(y=!1,E.value++,N<S?(o(A,")$"),A=f[++N],R(A),o(A,"^("),
M++):(x(A,w),M++)):w=="$"?(o(A,"\\$"),y&&x(c,"$"),M++):(((b||a)&&q("|*+?()[]{}.^\
$\\",w)!=r||w=="["&&H[M+1]=="]")&&x(A,"\\"),y&&x(c,w),x(A,w),M++);o(A,")$"),n&&(o(
n,A.data),A=f[--N]),e&&N>=0&&(o(e,A.data),A=f[--N]),s&&N>=0&&(i?o(s,c.data):o(s,
A.data))}function Za(t){let s;switch(t){case Fa:case va:case Ia:case Ma:case Ua:case Ja:case ka:case Wa:case Pa:case xa:case qa:
s="r";break;default:s="l";break}return s}function F(t,s,e,n,l){let a={},i,E,f;for(We(
a,s.topt,s.title,na(t),v(t)),Ee(s.translate_columns==r||s.translate_columns==null||
s.n_translate_columns>=a.ncolumns),i=0;i<a.ncolumns;i++)K(a,sa(t,i),s.translate_header,
Za(Va(t,i)));for(E=0;E<a.nrows;E++)for(f=0;f<a.ncolumns;f++){let N,c=!1,A;B(t,E,
f)?N=s.nullPrint?s.nullPrint:"":(N=_(t,E,f),a.aligns[f]=="r"&&s.topt.numericLocale&&
(N=format_numeric_locale(N),c=!0)),A=s.translate_columns&&s.translate_columns[f],
U(a,N,A,c)}if(s.footers){let N,c=0;for(N=s.footers[c];N;c++)C(a,N)}xe(a,e,n,l)}function We(t,s,e,n,l){
t.opt=s,t.title=e,t.ncolumns=n,t.nrows=l,t.headers=[],t.cells=[],t.footers=r,t.aligns=
[]}function K(t,s,e,n){e&&(s=s),t.headers.push(s),t.header=s,t.aligns.push(n),t.
align=n}function U(t,s,e,n){e&&(s=s),t.cells.push(s),t.cell=s}function C(t,s){t.
footers==r&&(t.footers=[]),t.footers.push(s),t.footer=s}function et(t,s){t.footers&&
t.footers.pop(),C(t,s)}function xe(t,s,e,n){Q.push({...t})}async function at(t,s,e,n){
let l=Me,a=q(e,"+")!=r,i={},E,f={value:Ea},N=n?Fe:ve;return R(i),E=fe(t,Ue,r,!0),
E?await nt(N,E,f)&&await st(N,f.value,i)?a?tt(i.data,n):Q.push(i.data):l=Ae:(k(n?
"function name is required":"view name is required"),l=Ae),l}function tt(t,s){let e=s,
n=0,l="";t=t.trimEnd().split(`
`);for(let a of t)e&&(de(a,"AS ",3)==0||de(a,"BEGIN ",6)==0||de(a,"RETURN ",7)==
0)&&(e=!1),e||n++,e?l+=Y(`        %s
`,a):l+=Y(`%-7d %s
`,n,a);Q.push(l)}async function nt(t,s,e){let n=!0,l={};R(l);let a;switch(t){case Fe:
o(l,"SELECT "),ue(l,s,p.db),u(l,"::pg_catalog.%s::pg_catalog.oid",q(s,"(")!==r?"\
regprocedure":"regproc");break;case ve:o(l,"SELECT "),ue(l,s,p.db),o(l,"::pg_cat\
alog.regclass::pg_catalog.oid");break}try{a=await O(l.data),a&&v(a)==1?e.value=Je(
_(a,0,0)):(k("Error when querying"),n=!1)}catch(i){k("ERROR:  "+i.message),n=!1}
return n}async function st(t,s,e){let n=!0,l={};R(l);let a;switch(t){case Fe:d(l,
"SELECT pg_catalog.pg_get_functiondef(%u)",s);break;case ve:p.sversion>=90400?d(
l,"SELECT nspname, relname, relkind, pg_catalog.pg_get_viewdef(c.oid, true), pg_\
catalog.array_remove(pg_catalog.array_remove(c.reloptions,'check_option=local'),\
'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.\
reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions)\
 THEN 'CASCADED'::text ELSE NULL END AS checkoption FROM pg_catalog.pg_class c L\
EFT JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid WHERE c.oid = %u",s):
d(l,"SELECT nspname, relname, relkind, pg_catalog.pg_get_viewdef(c.oid, true), c\
.reloptions AS reloptions, NULL AS checkoption FROM pg_catalog.pg_class c LEFT J\
OIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid WHERE c.oid = %u",s);break}
if(a=await O(l.data),a&&v(a)==1){switch(Ye(e),t){case Fe:o(e,_(a,0,0));break;case ve:
let i=_(a,0,0),E=_(a,0,1),f=_(a,0,2),N=_(a,0,3),c=_(a,0,4),A=_(a,0,5);switch(f[0]){case Oe:
o(e,"CREATE OR REPLACE VIEW ");break;default:k('"%s.%s" is not a view',i,E),n=!1;
break}u(e,"%s.",me(i)),o(e,me(E)),c!=r&&te(c)>2&&(o(e,`
 WITH (`),lt(e,c,"",p.encoding,p.db.standard_strings)||(k("could not parse relop\
tions array"),n=!1),x(e,")")),u(e,` AS
%s`,N),e.len>0&&e.data[e.len-1]==";"&&(e.data=e.data.slice(0,e.len-1)),A&&A[0]!=
r&&u(e,`
 WITH %s CHECK OPTION`,A);break}e.len>0&&e.data[e.len-1]!=`
`&&x(e,`
`)}else k("Error when querying"),n=!1;return n}function lt(t,s,e,n,l){let a=[],i={},
E;if(!it(s,a,i))return!1;for(i=i.value,E=0;E<i;E++){let f=a[E],[N,c]=f.split("=");
c??(c=""),E>0&&o(t,", "),u(t,"%s%s=",e,me(N)),D(me(c),c)==0?o(t,c):Be(t,c,n,l)}return!0}
function it(t,s,e){let n,l,a;if(n=te(t),e.value=0,n<2||t[0]!="{"||t[n-1]!="}")return!1;
let i=0;for(i++,a=0;t[i]!="}";){if(t[i]==r)return!1;for(l="";t[i]!="}"&&t[i]!=",";){
if(t[i]==r)return!1;if(t[i]!='"')l+=t[i++];else{for(i++;t[i]!='"';){if(t[i]==r||
t[i]=="\\"&&(i++,t[i]==r))return!1;l+=t[i++]}i++}}s[a]=l,t[i]==","&&i++,a++}return t[i+
1]&&t[i+1]!=r?!1:(e.value=a,!0)}function me(t){let s={};R(s);let e=!1;return _a?
e=!0:t[0]>="a"&&t[0]<="z"||t[0]=="_"?/[^a-z0-9_]/.test(t)&&(e=!0):e=!0,e||new Set(
["all","analyse","analyze","and","any","array","as","asc","asymmetric","authoriz\
ation","between","bigint","binary","bit","boolean","both","case","cast","char","\
character","check","coalesce","collate","collation","column","concurrently","con\
straint","create","cross","current_catalog","current_date","current_role","curre\
nt_schema","current_time","current_timestamp","current_user","dec","decimal","de\
fault","deferrable","desc","distinct","do","else","end","except","exists","extra\
ct","false","fetch","float","for","foreign","freeze","from","full","grant","grea\
test","group","grouping","having","ilike","in","initially","inner","inout","int",
"integer","intersect","interval","into","is","isnull","join","json","json_array",
"json_arrayagg","json_object","json_objectagg","json_scalar","json_serialize","l\
ateral","leading","least","left","like","limit","localtime","localtimestamp","na\
tional","natural","nchar","none","normalize","not","notnull","null","nullif","nu\
meric","offset","on","only","or","order","out","outer","overlaps","overlay","pla\
cing","position","precision","primary","real","references","returning","right","\
row","select","session_user","setof","similar","smallint","some","substring","sy\
mmetric","system_user","table","tablesample","then","time","timestamp","to","tra\
iling","treat","trim","true","union","unique","user","using","values","varchar",
"variadic","verbose","when","where","window","with","xmlattributes","xmlconcat",
"xmlelement","xmlexists","xmlforest","xmlnamespaces","xmlparse","xmlpi","xmlroot",
"xmlserialize","xmltable"]).has(t)&&(e=!0),e?(x(s,'"'),x(s,t.replace(/"/g,'""')),
x(s,'"')):o(s,t),s.data}async function rt(t,s,e){let n,l,a;return l=fe(t,pe,r,!0),
a=q(e,"+")!=r,n=await pt(l,a),n?Me:Ae}async function ot(t,s,e){let n=Me,l=!0,a,i,
E;switch(a=fe(t,pe,r,!0),i=q(e,"+")!=r,E=q(e,"S")!=r,e[1]){case void 0:case"+":case"\
S":a?l=await St(a,i,E):l=await pa("tvmsE",r,i,E);break;case"A":{let f=r;switch(a&&
e[2]!=r&&e[2]!="+"&&(f=fe(t,pe,r,!0)),e[2]){case void 0:case"+":l=await gt(a,i);
break;case"c":l=await Kt(a,f,i);break;case"f":l=await Xt(a,f,i);break;case"o":l=
await Zt(a,f,i);break;case"p":l=await en(a,f,i);break;default:n=X;break}}break;case"\
a":l=await ct(a,i,E);break;case"b":l=await ft(a,i);break;case"c":de(e,"dconfig",
7)==0?l=await Dt(a,i,E):l=await Lt(a,i,E);break;case"C":l=await Ht(a,i);break;case"\
d":de(e,"ddp",3)==0?l=await mt(a):l=await Nt(a,E);break;case"D":l=await bt(a,i,E);
break;case"f":switch(e[2]){case void 0:case"+":case"S":case"a":case"n":case"p":case"\
t":case"w":l=await ra(t,e,a,i,E);break;default:n=X;break}break;case"g":l=await oa(
a,i,E);break;case"l":l=await an(i);break;case"L":l=await yt(a,i,E);break;case"n":
l=await It(a,i,E);break;case"o":l=await ra(t,e,a,i,E);break;case"O":l=await Ct(a,
i,E);break;case"p":l=await Et(a,E);break;case"P":switch(e[2]){case void 0:case"+":case"\
t":case"i":case"n":l=await Rt(e.slice(2),a,i);break;default:n=X;break}break;case"\
T":l=await dt(a,i,E);break;case"t":case"v":case"m":case"i":case"s":case"E":l=await pa(
e[1],a,i,E);break;case"r":if(e[2]=="d"&&e[3]=="s"){let f=r;a&&(f=fe(t,pe,r,!0)),
l=await Tt(a,f)}else e[2]=="g"?l=await Ot(a,E):n=X;break;case"R":switch(e[2]){case"\
p":i?l=await Vt(a):l=await Qt(a);break;case"s":l=await Gt(a,i);break;default:n=X}
break;case"u":l=await oa(a,i,E);break;case"F":switch(e[2]){case void 0:case"+":l=
await Pt(a,i);break;case"p":l=await Ft(a,i);break;case"d":l=await Wt(a,i);break;case"\
t":l=await xt(a,i);break;default:n=X;break}break;case"e":switch(e[2]){case"s":l=
await Jt(a,i);break;case"u":l=await Yt(a,i);break;case"w":l=await qt(a,i);break;case"\
t":l=await Bt(a,i);break;default:n=X;break}break;case"x":i?l=await zt(a):l=await jt(
a);break;case"X":l=await wt(a);break;case"y":l=await ht(a,i);break;default:n=X}return l||
(n=Ae),n}async function ra(t,s,e,n,l){let a,i=[],E=0;if(e){let f;for(;(f=fe(t,pe,
r,!0))!=r&&(i[E++]=f,!(E>=da)););}return s[1]=="f"?a=await _t(s.slice(2),e,i,E,n,
l):a=await ut(e,i,E,n,l),a}async function pt(t,s){let e,n={},l=p.popt;return R(n),
d(n,`SELECT
  d.datname as "%s",
  pg_catalog.pg_get_userbyid(d.datdba) as "%s",
  pg_catalog.pg_encoding_to_char(d.encoding) as "%s",
`,"Name","Owner","Encoding"),p.sversion>=15e4?u(n,`  CASE d.datlocprovider WHEN \
'c' THEN 'libc' WHEN 'i' THEN 'icu' END AS "%s",
`,"Locale Provider"):u(n,`  'libc' AS "%s",
`,"Locale Provider"),u(n,`  d.datcollate as "%s",
  d.datctype as "%s",
`,"Collate","Ctype"),p.sversion>=15e4?u(n,`  d.daticulocale as "%s",
`,"ICU Locale"):u(n,`  NULL as "%s",
`,"ICU Locale"),p.sversion>=16e4?u(n,`  d.daticurules as "%s",
`,"ICU Rules"):u(n,`  NULL as "%s",
`,"ICU Rules"),o(n,"  "),V(n,"d.datacl"),s&&u(n,`,
  CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT')
       THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))
       ELSE 'No Access'
  END as "%s",
  t.spcname as "%s",
  pg_catalog.shobj_description(d.oid, 'pg_database') as "%s"`,"Size","Tablespace",
"Description"),o(n,`
FROM pg_catalog.pg_database d
`),s&&o(n,`  JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid
`),t&&!h(n,t,!1,!1,r,"d.datname",r,r,r,1)||(o(n,"ORDER BY 1;"),e=await O(n.data),
!e)?!1:(l.nullPrint=r,l.title="List of databases",l.translate_header=!0,F(e,l,p.
queryFout,!1,p.logfile),!0)}async function ct(t,s,e){let n={},l,a=p.popt;return R(
n),d(n,`SELECT n.nspname as "%s",
  p.proname AS "%s",
  pg_catalog.format_type(p.prorettype, NULL) AS "%s",
  CASE WHEN p.pronargs = 0
    THEN CAST('*' AS pg_catalog.text)
    ELSE pg_catalog.pg_get_function_arguments(p.oid)
  END AS "%s",
`,"Schema","Name","Result data type","Argument data types"),p.sversion>=11e4?u(n,
`  pg_catalog.obj_description(p.oid, 'pg_proc') as "%s"
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE p.prokind = 'a'
`,"Description"):u(n,`  pg_catalog.obj_description(p.oid, 'pg_proc') as "%s"
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE p.proisagg
`,"Description"),!e&&!t&&o(n,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(n,t,!0,!1,"n.nspname","p.proname",r,"pg_catalog.pg_function_is_visible(p.o\
id)",r,3)||(o(n,"ORDER BY 1, 2, 4;"),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title=
"List of aggregate functions",a.translate_header=!0,F(l,a,p.queryFout,!1,p.logfile),
!0)}async function gt(t,s){let e={},n,l=p.popt,a=[!1,!0,!1,!1];if(p.sversion<90600){
let i;return k("The server (version %s) does not support access methods.",oe(p.sversion,
!1,i,re(i))),!0}return R(e),d(e,`SELECT amname AS "%s",
  CASE amtype WHEN 'i' THEN '%s' WHEN 't' THEN '%s' END AS "%s"`,"Name","Index",
"Table","Type"),s&&u(e,`,
  amhandler AS "%s",
  pg_catalog.obj_description(oid, 'pg_am') AS "%s"`,"Handler","Description"),o(e,
`
FROM pg_catalog.pg_am
`),!h(e,t,!1,!1,r,"amname",r,r,r,1)||(o(e,"ORDER BY 1;"),n=await O(e.data),!n)?!1:
(l.nullPrint=r,l.title="List of access methods",l.translate_header=!0,l.translate_columns=
a,l.n_translate_columns=J(a),F(n,l,p.queryFout,!1,p.logfile),!0)}async function ft(t,s){
let e={},n,l=p.popt;return R(e),d(e,`SELECT spcname AS "%s",
  pg_catalog.pg_get_userbyid(spcowner) AS "%s",
  pg_catalog.pg_tablespace_location(oid) AS "%s"`,"Name","Owner","Location"),s&&
(o(e,`,
  `),V(e,"spcacl"),u(e,`,
  spcoptions AS "%s",
  pg_catalog.pg_size_pretty(pg_catalog.pg_tablespace_size(oid)) AS "%s",
  pg_catalog.shobj_description(oid, 'pg_tablespace') AS "%s"`,"Options","Size","\
Description")),o(e,`
FROM pg_catalog.pg_tablespace
`),!h(e,t,!1,!1,r,"spcname",r,r,r,1)||(o(e,"ORDER BY 1;"),n=await O(e.data),!n)?
!1:(l.nullPrint=r,l.title="List of tablespaces",l.translate_header=!0,F(n,l,p.queryFout,
!1,p.logfile),!0)}async function _t(t,s,e,n,l,a){let i=q(t,"a")!=r,E=q(t,"n")!=r,
f=q(t,"p")!=r,N=q(t,"t")!=r,c=q(t,"w")!=r,A,S={},b,y=p.popt,H=[!1,!1,!1,!1,!0,!0,
!0,!1,!0,!1,!1,!1,!1],M=[!1,!1,!1,!1,!0,!0,!1,!0,!1,!1,!1,!1];if(te(t)!=$a(t,"an\
ptwS+"))return k("\\df only takes [anptwS+] as options"),!0;if(f&&p.sversion<11e4){
let w;return k('\\df does not take a "%c" option with server version %s',"p",oe(
p.sversion,!1,w,re(w))),!0}!i&&!E&&!f&&!N&&!c&&(i=E=N=c=!0,p.sversion>=11e4&&(f=
!0)),R(S),d(S,`SELECT n.nspname as "%s",
  p.proname as "%s",
`,"Schema","Name"),p.sversion>=11e4?u(S,`  pg_catalog.pg_get_function_result(p.o\
id) as "%s",
  pg_catalog.pg_get_function_arguments(p.oid) as "%s",
 CASE p.prokind
  WHEN 'a' THEN '%s'
  WHEN 'w' THEN '%s'
  WHEN 'p' THEN '%s'
  ELSE '%s'
 END as "%s"`,"Result data type","Argument data types","agg","window","proc","fu\
nc","Type"):u(S,`  pg_catalog.pg_get_function_result(p.oid) as "%s",
  pg_catalog.pg_get_function_arguments(p.oid) as "%s",
 CASE
  WHEN p.proisagg THEN '%s'
  WHEN p.proiswindow THEN '%s'
  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'
  ELSE '%s'
 END as "%s"`,"Result data type","Argument data types","agg","window","trigger",
"func","Type"),l&&(u(S,`,
 CASE
  WHEN p.provolatile = 'i' THEN '%s'
  WHEN p.provolatile = 's' THEN '%s'
  WHEN p.provolatile = 'v' THEN '%s'
 END as "%s"`,"immutable","stable","volatile","Volatility"),p.sversion>=90600&&u(
S,`,
 CASE
  WHEN p.proparallel = 'r' THEN '%s'
  WHEN p.proparallel = 's' THEN '%s'
  WHEN p.proparallel = 'u' THEN '%s'
 END as "%s"`,"restricted","safe","unsafe","Parallel"),u(S,`,
 pg_catalog.pg_get_userbyid(p.proowner) as "%s",
 CASE WHEN prosecdef THEN '%s' ELSE '%s' END AS "%s"`,"Owner","definer","invoker",
"Security"),o(S,`,
 `),V(S,"p.proacl"),u(S,`,
 l.lanname as "%s"`,"Language"),u(S,`,
 CASE WHEN l.lanname IN ('internal', 'c') THEN p.prosrc END as "%s"`,"Internal n\
ame"),u(S,`,
 pg_catalog.obj_description(p.oid, 'pg_proc') as "%s"`,"Description")),o(S,`
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
`);for(let w=0;w<n;w++)u(S,`     LEFT JOIN pg_catalog.pg_type t%d ON t%d.oid = p\
.proargtypes[%d]
     LEFT JOIN pg_catalog.pg_namespace nt%d ON nt%d.oid = t%d.typnamespace
`,w,w,w,w,w,w);if(l&&o(S,`     LEFT JOIN pg_catalog.pg_language l ON l.oid = p.p\
rolang
`),A=!1,!(E&&i&&f&&N&&c))if(E)i||(A?o(S,"      AND "):(o(S,"WHERE "),A=!0),p.sversion>=
11e4?o(S,`p.prokind <> 'a'
`):o(S,`NOT p.proisagg
`)),!f&&p.sversion>=11e4&&(A?o(S,"      AND "):(o(S,"WHERE "),A=!0),o(S,`p.proki\
nd <> 'p'
`)),N||(A?o(S,"      AND "):(o(S,"WHERE "),A=!0),o(S,`p.prorettype <> 'pg_catalo\
g.trigger'::pg_catalog.regtype
`)),c||(A?o(S,"      AND "):(o(S,"WHERE "),A=!0),p.sversion>=11e4?o(S,`p.prokind\
 <> 'w'
`):o(S,`NOT p.proiswindow
`));else{let w=!1;o(S,`WHERE (
       `),A=!0,i&&(p.sversion>=11e4?o(S,`p.prokind = 'a'
`):o(S,`p.proisagg
`),w=!0),N&&(w&&o(S,"       OR "),o(S,`p.prorettype = 'pg_catalog.trigger'::pg_c\
atalog.regtype
`),w=!0),f&&(w&&o(S,"       OR "),o(S,`p.prokind = 'p'
`),w=!0),c&&(w&&o(S,"       OR "),p.sversion>=11e4?o(S,`p.prokind = 'w'
`):o(S,`p.proiswindow
`)),o(S,`      )
`)}if(!h(S,s,A,!1,"n.nspname","p.proname",r,"pg_catalog.pg_function_is_visible(p\
.oid)",r,3))return!1;for(let w=0;w<n;w++)if(D(e[w],"-")!=0){let j,ne,se,Ne;if(j=
Y("nt%d.nspname",w),ne=Y("t%d.typname",w),se=Y("pg_catalog.format_type(t%d.oid, \
NULL)",w),Ne=Y("pg_catalog.pg_type_is_visible(t%d.oid)",w),!h(S,ze(e[w]),!0,!1,j,
ne,se,Ne,r,3))return!1}else u(S,`  AND t%d.typname IS NULL
`,w);return!a&&!s&&o(S,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),o(S,"ORDER BY 1, 2, 4;"),b=await O(S.data),b?(y.nullPrint=r,y.title="List of \
functions",y.translate_header=!0,p.sversion>=90600?(y.translate_columns=H,y.n_translate_columns=
J(H)):(y.translate_columns=M,y.n_translate_columns=J(M)),F(b,y,p.queryFout,!1,p.
logfile),!0):!1}async function dt(t,s,e){let n={},l,a=p.popt;return R(n),d(n,`SE\
LECT n.nspname as "%s",
  pg_catalog.format_type(t.oid, NULL) AS "%s",
`,"Schema","Name"),s&&(u(n,`  t.typname AS "%s",
  CASE WHEN t.typrelid != 0
      THEN CAST('tuple' AS pg_catalog.text)
    WHEN t.typlen < 0
      THEN CAST('var' AS pg_catalog.text)
    ELSE CAST(t.typlen AS pg_catalog.text)
  END AS "%s",
  pg_catalog.array_to_string(
      ARRAY(
          SELECT e.enumlabel
          FROM pg_catalog.pg_enum e
          WHERE e.enumtypid = t.oid
          ORDER BY e.enumsortorder
      ),
      E'\\n'
  ) AS "%s",
  pg_catalog.pg_get_userbyid(t.typowner) AS "%s",
`,"Internal name","Size","Elements","Owner"),V(n,"t.typacl"),o(n,`,
  `)),u(n,`  pg_catalog.obj_description(t.oid, 'pg_type') as "%s"
`,"Description"),o(n,`FROM pg_catalog.pg_type t
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
`),o(n,"WHERE (t.typrelid = 0 "),o(n,`OR (SELECT c.relkind = 'c' FROM pg_catalog\
.pg_class c WHERE c.oid = t.typrelid))
`),(t==r||ke(t,"[]")==r)&&o(n,`  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type\
 el WHERE el.oid = t.typelem AND el.typarray = t.oid)
`),!e&&!t&&o(n,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(n,ze(t),!0,!1,"n.nspname","t.typname","pg_catalog.format_type(t.oid, NULL)",
"pg_catalog.pg_type_is_visible(t.oid)",r,3)||(o(n,"ORDER BY 1, 2;"),l=await O(n.
data),!l)?!1:(a.nullPrint=r,a.title="List of data types",a.translate_header=!0,F(
l,a,p.queryFout,!1,p.logfile),!0)}function ze(t){let s=["decimal","numeric","flo\
at","double precision","int","integer","bool[]","boolean[]","decimal[]","numeric\
[]","float[]","double precision[]","float4[]","real[]","float8[]","double precis\
ion[]","int[]","integer[]","int2[]","smallint[]","int4[]","integer[]","int8[]","\
bigint[]","time[]","time without time zone[]","timetz[]","time with time zone[]",
"timestamp[]","timestamp without time zone[]","timestamptz[]","timestamp with ti\
me zone[]","varbit[]","bit varying[]","varchar[]","character varying[]",r];if(t==
r)return r;for(let e=0;s[e]!=r;e+=2)if(Ka(t,s[e])==0)return s[e+1];return t}async function ut(t,s,e,n,l){
let a={},i,E=p.popt;if(R(a),d(a,`SELECT n.nspname as "%s",
  o.oprname AS "%s",
  CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL)\
 END AS "%s",
  CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL\
) END AS "%s",
  pg_catalog.format_type(o.oprresult, NULL) AS "%s",
`,"Schema","Name","Left arg type","Right arg type","Result type"),n&&u(a,`  o.op\
rcode AS "%s",
`,"Function"),u(a,`  coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),
           pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS "%s"
FROM pg_catalog.pg_operator o
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace
`,"Description"),e>=2?(e=2,o(a,`     LEFT JOIN pg_catalog.pg_type t0 ON t0.oid =\
 o.oprleft
     LEFT JOIN pg_catalog.pg_namespace nt0 ON nt0.oid = t0.typnamespace
     LEFT JOIN pg_catalog.pg_type t1 ON t1.oid = o.oprright
     LEFT JOIN pg_catalog.pg_namespace nt1 ON nt1.oid = t1.typnamespace
`)):e==1&&o(a,`     LEFT JOIN pg_catalog.pg_type t0 ON t0.oid = o.oprright
     LEFT JOIN pg_catalog.pg_namespace nt0 ON nt0.oid = t0.typnamespace
`),!l&&!t&&o(a,`WHERE n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(a,t,!l&&!t,!0,"n.nspname","o.oprname",r,"pg_catalog.pg_operator_is_visible\
(o.oid)",r,3))return!1;e==1&&o(a,`  AND o.oprleft = 0
`);for(let f=0;f<e;f++)if(D(s[f],"-")!=0){let N,c,A,S;if(N=Y("nt%d.nspname",f),c=
Y("t%d.typname",f),A=Y("pg_catalog.format_type(t%d.oid, NULL)",f),S=Y("pg_catalo\
g.pg_type_is_visible(t%d.oid)",f),!h(a,ze(s[f]),!0,!1,N,c,A,S,r,3))return!1}else
u(a,`  AND t%d.typname IS NULL
`,f);return o(a,"ORDER BY 1, 2, 3, 4;"),i=await O(a.data),i?(E.nullPrint=r,E.title=
"List of operators",E.translate_header=!0,F(i,E,p.queryFout,!1,p.logfile),!0):!1}
async function Et(t,s){let e={},n,l=p.popt,a=[!1,!1,!0,!1,!1,!1];return R(e),d(e,
`SELECT n.nspname as "%s",
  c.relname as "%s",
  CASE c.relkind WHEN 'r' THEN '%s' WHEN 'v' THEN '%s' WHEN 'm' THEN '%s' WHEN '\
S' THEN '%s' WHEN 'f' THEN '%s' WHEN 'p' THEN '%s' END as "%s",
  `,"Schema","Name","table","view","materialized view","sequence","foreign table",
"partitioned table","Type"),V(e,"c.relacl"),u(e,`,
  pg_catalog.array_to_string(ARRAY(
    SELECT attname || E':\\n  ' || pg_catalog.array_to_string(attacl, E'\\n  ')
    FROM pg_catalog.pg_attribute a
    WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL
  ), E'\\n') AS "%s"`,"Column privileges"),p.sversion>=90500&&p.sversion<1e5&&u(
e,`,
  pg_catalog.array_to_string(ARRAY(
    SELECT polname
    || CASE WHEN polcmd != '*' THEN
           E' (' || polcmd::pg_catalog.text || E'):'
       ELSE E':'
       END
    || CASE WHEN polqual IS NOT NULL THEN
           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)
       ELSE E''
       END
    || CASE WHEN polwithcheck IS NOT NULL THEN
           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)
       ELSE E''
       END    || CASE WHEN polroles <> '{0}' THEN
           E'\\n  to: ' || pg_catalog.array_to_string(
               ARRAY(
                   SELECT rolname
                   FROM pg_catalog.pg_roles
                   WHERE oid = ANY (polroles)
                   ORDER BY 1
               ), E', ')
       ELSE E''
       END
    FROM pg_catalog.pg_policy pol
    WHERE polrelid = c.oid), E'\\n')
    AS "%s"`,"Policies"),p.sversion>=1e5&&u(e,`,
  pg_catalog.array_to_string(ARRAY(
    SELECT polname
    || CASE WHEN NOT polpermissive THEN
       E' (RESTRICTIVE)'
       ELSE '' END
    || CASE WHEN polcmd != '*' THEN
           E' (' || polcmd::pg_catalog.text || E'):'
       ELSE E':'
       END
    || CASE WHEN polqual IS NOT NULL THEN
           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)
       ELSE E''
       END
    || CASE WHEN polwithcheck IS NOT NULL THEN
           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)
       ELSE E''
       END    || CASE WHEN polroles <> '{0}' THEN
           E'\\n  to: ' || pg_catalog.array_to_string(
               ARRAY(
                   SELECT rolname
                   FROM pg_catalog.pg_roles
                   WHERE oid = ANY (polroles)
                   ORDER BY 1
               ), E', ')
       ELSE E''
       END
    FROM pg_catalog.pg_policy pol
    WHERE polrelid = c.oid), E'\\n')
    AS "%s"`,"Policies"),o(e,`
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind IN ('r','v','m','S','f','p')
`),!s&&!t&&o(e,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!0,!1,"n.nspname","c.relname",r,"pg_catalog.pg_table_is_visible(c.oid)",
r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,d(e,"Access\
 privileges"),l.title=e.data,l.translate_header=!0,l.translate_columns=a,l.n_translate_columns=
J(a),F(n,l,p.queryFout,!1,p.logfile),!0)}async function mt(t){let s={},e,n=p.popt,
l=[!1,!1,!0,!1];return R(s),d(s,`SELECT pg_catalog.pg_get_userbyid(d.defaclrole)\
 AS "%s",
  n.nspname AS "%s",
  CASE d.defaclobjtype WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%\
s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' END AS "%s",
  `,"Owner","Schema",Ra,"table",ya,"sequence",ba,"function",La,"type",Da,"schema",
"Type"),V(s,"d.defaclacl"),o(s,`
FROM pg_catalog.pg_default_acl d
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.defaclnamespace
`),!h(s,t,!1,!1,r,"n.nspname","pg_catalog.pg_get_userbyid(d.defaclrole)",r,r,3)||
(o(s,"ORDER BY 1, 2, 3;"),e=await O(s.data),!e)?!1:(n.nullPrint=r,d(s,"Default a\
ccess privileges"),n.title=s.data,n.translate_header=!0,n.translate_columns=l,n.
n_translate_columns=J(l),F(e,n,p.queryFout,!1,p.logfile),!0)}async function Nt(t,s){
let e={},n,l=p.popt,a=[!1,!1,!0,!1];return R(e),u(e,`SELECT DISTINCT tt.nspname \
AS "%s", tt.name AS "%s", tt.object AS "%s", d.description AS "%s"
FROM (
`,"Schema","Name","Object","Description"),u(e,`  SELECT pgc.oid as oid, pgc.tabl\
eoid AS tableoid,
  n.nspname as nspname,
  CAST(pgc.conname AS pg_catalog.text) as name,  CAST('%s' AS pg_catalog.text) a\
s object
  FROM pg_catalog.pg_constraint pgc
    JOIN pg_catalog.pg_class c ON c.oid = pgc.conrelid
    LEFT JOIN pg_catalog.pg_namespace n     ON n.oid = c.relnamespace
`,"table constraint"),!s&&!t&&o(e,`WHERE n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!s&&!t,!1,"n.nspname","pgc.conname",r,"pg_catalog.pg_table_is_visible(\
c.oid)",r,3)||(u(e,`UNION ALL
  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,
  n.nspname as nspname,
  CAST(pgc.conname AS pg_catalog.text) as name,  CAST('%s' AS pg_catalog.text) a\
s object
  FROM pg_catalog.pg_constraint pgc
    JOIN pg_catalog.pg_type t ON t.oid = pgc.contypid
    LEFT JOIN pg_catalog.pg_namespace n     ON n.oid = t.typnamespace
`,"domain constraint"),!s&&!t&&o(e,`WHERE n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!s&&!t,!1,"n.nspname","pgc.conname",r,"pg_catalog.pg_type_is_visible(t\
.oid)",r,3))||(u(e,`UNION ALL
  SELECT o.oid as oid, o.tableoid as tableoid,
  n.nspname as nspname,
  CAST(o.opcname AS pg_catalog.text) as name,
  CAST('%s' AS pg_catalog.text) as object
  FROM pg_catalog.pg_opclass o
    JOIN pg_catalog.pg_am am ON o.opcmethod = am.oid
    JOIN pg_catalog.pg_namespace n ON n.oid = o.opcnamespace
`,"operator class"),!s&&!t&&o(e,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!0,!1,"n.nspname","o.opcname",r,"pg_catalog.pg_opclass_is_visible(o.oi\
d)",r,3))||(u(e,`UNION ALL
  SELECT opf.oid as oid, opf.tableoid as tableoid,
  n.nspname as nspname,
  CAST(opf.opfname AS pg_catalog.text) AS name,
  CAST('%s' AS pg_catalog.text) as object
  FROM pg_catalog.pg_opfamily opf
    JOIN pg_catalog.pg_am am ON opf.opfmethod = am.oid
    JOIN pg_catalog.pg_namespace n ON opf.opfnamespace = n.oid
`,"operator family"),!s&&!t&&o(e,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!0,!1,"n.nspname","opf.opfname",r,"pg_catalog.pg_opfamily_is_visible(o\
pf.oid)",r,3))||(u(e,`UNION ALL
  SELECT r.oid as oid, r.tableoid as tableoid,
  n.nspname as nspname,
  CAST(r.rulename AS pg_catalog.text) as name,  CAST('%s' AS pg_catalog.text) as\
 object
  FROM pg_catalog.pg_rewrite r
       JOIN pg_catalog.pg_class c ON c.oid = r.ev_class
       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
  WHERE r.rulename != '_RETURN'
`,"rule"),!s&&!t&&o(e,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!0,!1,"n.nspname","r.rulename",r,"pg_catalog.pg_table_is_visible(c.oid\
)",r,3))||(u(e,`UNION ALL
  SELECT t.oid as oid, t.tableoid as tableoid,
  n.nspname as nspname,
  CAST(t.tgname AS pg_catalog.text) as name,  CAST('%s' AS pg_catalog.text) as o\
bject
  FROM pg_catalog.pg_trigger t
       JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
`,"trigger"),!s&&!t&&o(e,`WHERE n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(e,t,!s&&!t,!1,"n.nspname","t.tgname",r,"pg_catalog.pg_table_is_visible(c.o\
id)",r,3))||(o(e,`) AS tt
  JOIN pg_catalog.pg_description d ON (tt.oid = d.objoid AND tt.tableoid = d.cla\
ssoid AND d.objsubid = 0)
`),o(e,"ORDER BY 1, 2, 3;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title="Obj\
ect descriptions",l.translate_header=!0,l.translate_columns=a,l.n_translate_columns=
J(a),F(n,l,p.queryFout,!1,p.logfile),!0)}async function St(t,s,e){let n={},l,a;if(R(
n),d(n,`SELECT c.oid,
  n.nspname,
  c.relname
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
`),!e&&!t&&o(n,`WHERE n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(n,t,!e&&!t,!1,"n.nspname","c.relname",r,"pg_catalog.pg_table_is_visible(c.\
oid)",r,3)||(o(n,"ORDER BY 2, 3;"),l=await O(n.data),!l))return!1;if(v(l)==0)return p.
quiet||(t?k('Did not find any relation named "%s".',t):k("Did not find any relat\
ions.")),!1;for(a=0;a<v(l);a++){let i,E,f;if(i=_(l,a,0),E=_(l,a,1),f=_(l,a,2),!await At(
E,f,i,s)||Ie)return!1}return!0}async function At(t,s,e,n){let l=!1,a={},i=r,E=p.
popt.topt,f={},N=!1,c,A=r,S=[],b={},y={},H,M=-1,w=-1,j=-1,ne=-1,se=-1,Ne=-1,Qe=-1,
ye=-1,be=-1,Le=-1,De=-1,he=-1,we=-1,He=-1,Pe,m={},Ce=!1;if(E.default_footer=!1,E.
expanded=!1,R(a),R(b),R(y),p.sversion>=12e4?d(a,`SELECT c.relchecks, c.relkind, \
c.relhasindex, c.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerows\
ecurity, false AS relhasoids, c.relispartition, %s, c.reltablespace, CASE WHEN c\
.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END\
, c.relpersistence, c.relreplident, am.amname
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)
WHERE c.oid = '%s';`,n?`pg_catalog.array_to_string(c.reloptions || array(select \
'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
`:"''",e):p.sversion>=1e5?d(a,`SELECT c.relchecks, c.relkind, c.relhasindex, c.r\
elhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relhaso\
ids, c.relispartition, %s, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' EL\
SE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersistence, c.rel\
replident
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
WHERE c.oid = '%s';`,n?`pg_catalog.array_to_string(c.reloptions || array(select \
'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
`:"''",e):p.sversion>=90500?d(a,`SELECT c.relchecks, c.relkind, c.relhasindex, c\
.relhasrules, c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, c.relha\
soids, false as relispartition, %s, c.reltablespace, CASE WHEN c.reloftype = 0 T\
HEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, c.relpersisten\
ce, c.relreplident
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
WHERE c.oid = '%s';`,n?`pg_catalog.array_to_string(c.reloptions || array(select \
'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
`:"''",e):p.sversion>=90400?d(a,`SELECT c.relchecks, c.relkind, c.relhasindex, c\
.relhasrules, c.relhastriggers, false, false, c.relhasoids, false as relispartit\
ion, %s, c.reltablespace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg\
_catalog.regtype::pg_catalog.text END, c.relpersistence, c.relreplident
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
WHERE c.oid = '%s';`,n?`pg_catalog.array_to_string(c.reloptions || array(select \
'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
`:"''",e):d(a,`SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, c.re\
lhastriggers, false, false, c.relhasoids, false as relispartition, %s, c.reltabl\
espace, CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::\
pg_catalog.text END, c.relpersistence
FROM pg_catalog.pg_class c
 LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)
WHERE c.oid = '%s';`,n?`pg_catalog.array_to_string(c.reloptions || array(select \
'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')
`:"''",e),i=await O(a.data),!i)return l;if(v(i)==0)return p.quiet||k("Did not fi\
nd any relation with OID %s.",e),l;if(m.checks=Ze(_(i,0,0)),m.relkind=_(i,0,1),m.
hasindex=D(_(i,0,2),"t")==0,m.hasrules=D(_(i,0,3),"t")==0,m.hastriggers=D(_(i,0,
4),"t")==0,m.rowsecurity=D(_(i,0,5),"t")==0,m.forcerowsecurity=D(_(i,0,6),"t")==
0,m.hasoids=D(_(i,0,7),"t")==0,m.ispartition=D(_(i,0,8),"t")==0,m.reloptions=_(i,
0,9),m.tablespace=Je(_(i,0,10)),m.reloftype=D(_(i,0,11),"")!=0?_(i,0,11):r,m.relpersistence=
_(i,0,12),m.relreplident=p.sversion>=90400?_(i,0,13):"d",p.sversion>=12e4?m.relam=
B(i,0,14)?r:_(i,0,14):m.relam=r,i=r,m.relkind==Ca){let g=r,T=p.popt,L=[r,r];if(p.
sversion>=1e5?(d(a,`SELECT pg_catalog.format_type(seqtypid, NULL) AS "%s",
       seqstart AS "%s",
       seqmin AS "%s",
       seqmax AS "%s",
       seqincrement AS "%s",
       CASE WHEN seqcycle THEN '%s' ELSE '%s' END AS "%s",
       seqcache AS "%s"
`,"Type","Start","Minimum","Maximum","Increment","yes","no","Cycles?","Cache"),u(
a,`FROM pg_catalog.pg_sequence
WHERE seqrelid = '%s';`,e)):(d(a,`SELECT 'bigint' AS "%s",
       start_value AS "%s",
       min_value AS "%s",
       max_value AS "%s",
       increment_by AS "%s",
       CASE WHEN is_cycled THEN '%s' ELSE '%s' END AS "%s",
       cache_value AS "%s"
`,"Type","Start","Minimum","Maximum","Increment","yes","no","Cycles?","Cache"),u(
a,"FROM %s",me(t)),u(a,".%s;",me(s))),i=await O(a.data),!i)return l;if(d(a,`SELE\
CT pg_catalog.quote_ident(nspname) || '.' ||
   pg_catalog.quote_ident(relname) || '.' ||
   pg_catalog.quote_ident(attname),
   d.deptype
FROM pg_catalog.pg_class c
INNER JOIN pg_catalog.pg_depend d ON c.oid=d.refobjid
INNER JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
INNER JOIN pg_catalog.pg_attribute a ON (
 a.attrelid=c.oid AND
 a.attnum=d.refobjsubid)
WHERE d.classid='pg_catalog.pg_class'::pg_catalog.regclass
 AND d.refclassid='pg_catalog.pg_class'::pg_catalog.regclass
 AND d.objid='%s'
 AND d.deptype IN ('a', 'i')`,e),g=await O(a.data),g){if(v(g)==1)switch(_(g,0,1)[0]){case"\
a":L[0]=psprintf("Owned by: %s",_(g,0,0));break;case"i":L[0]=psprintf("Sequence \
for identity column: %s",_(g,0,0));break}}else return l;return m.relpersistence==
"u"?d(b,'Unlogged sequence "%s.%s"',t,s):d(b,'Sequence "%s.%s"',t,s),T.footers=L,
T.topt.default_footer=!1,T.title=b.data,T.translate_header=!0,F(i,T,p.queryFout,
!1,p.logfile),l=!0,l}if((m.relkind==Z||m.relkind==Oe||m.relkind==G||m.relkind==ee||
m.relkind==qe||m.relkind==$)&&(Ce=!0),H=0,d(a,"SELECT a.attname"),M=H++,o(a,`,
  pg_catalog.format_type(a.atttypid, a.atttypmod)`),w=H++,Ce&&(o(a,`,
  (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true)
   FROM pg_catalog.pg_attrdef d
   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef),
  a.attnotnull`),j=H++,ne=H++,o(a,`,
  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t
   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.t\
ypcollation) AS attcollation`),se=H++,p.sversion>=1e5?o(a,`,
  a.attidentity`):o(a,`,
  ''::pg_catalog.char AS attidentity`),Ne=H++,p.sversion>=12e4?o(a,`,
  a.attgenerated`):o(a,`,
  ''::pg_catalog.char AS attgenerated`),Qe=H++),(m.relkind==ce||m.relkind==ae)&&
(p.sversion>=11e4&&(u(a,`,
  CASE WHEN a.attnum <= (SELECT i.indnkeyatts FROM pg_catalog.pg_index i WHERE i\
.indexrelid = '%s') THEN '%s' ELSE '%s' END AS is_key`,e,"yes","no"),ye=H++),o(a,
`,
  pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE) AS indexdef`),be=H++),m.
relkind==ee&&(o(a,`,
  CASE WHEN attfdwoptions IS NULL THEN '' ELSE   '(' || pg_catalog.array_to_stri\
ng(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_l\
iteral(option_value)  FROM   pg_catalog.pg_options_to_table(attfdwoptions)), ', \
') || ')' END AS attfdwoptions`),Le=H++),n&&(o(a,`,
  a.attstorage`),De=H++,p.sversion>=14e4&&!p.hide_compression&&(m.relkind==Z||m.
relkind==$||m.relkind==G)&&(o(a,`,
  a.attcompression AS attcompression`),he=H++),(m.relkind==Z||m.relkind==ce||m.relkind==
ae||m.relkind==G||m.relkind==ee||m.relkind==$)&&(o(a,`,
  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarg\
et`),we=H++),(m.relkind==Z||m.relkind==Oe||m.relkind==G||m.relkind==ee||m.relkind==
qe||m.relkind==$)&&(o(a,`,
  pg_catalog.col_description(a.attrelid, a.attnum)`),He=H++)),o(a,`
FROM pg_catalog.pg_attribute a`),u(a,`
WHERE a.attrelid = '%s' AND a.attnum > 0 AND NOT a.attisdropped`,e),o(a,`
ORDER BY a.attnum;`),i=await O(a.data),!i)return l;switch(Pe=v(i),m.relkind){case Z:
m.relpersistence=="u"?d(b,'Unlogged table "%s.%s"',t,s):d(b,'Table "%s.%s"',t,s);
break;case Oe:d(b,'View "%s.%s"',t,s);break;case G:m.relpersistence=="u"?d(b,'Un\
logged materialized view "%s.%s"',t,s):d(b,'Materialized view "%s.%s"',t,s);break;case ce:
m.relpersistence=="u"?d(b,'Unlogged index "%s.%s"',t,s):d(b,'Index "%s.%s"',t,s);
break;case ae:m.relpersistence=="u"?d(b,'Unlogged partitioned index "%s.%s"',t,s):
d(b,'Partitioned index "%s.%s"',t,s);break;case Te:d(b,'TOAST table "%s.%s"',t,s);
break;case qe:d(b,'Composite type "%s.%s"',t,s);break;case ee:d(b,'Foreign table\
 "%s.%s"',t,s);break;case $:m.relpersistence=="u"?d(b,'Unlogged partitioned tabl\
e "%s.%s"',t,s):d(b,'Partitioned table "%s.%s"',t,s);break;default:d(b,'?%c? "%s\
.%s"',m.relkind,t,s);break}for(H=0,S[H++]="Column",S[H++]="Type",Ce&&(S[H++]="Co\
llation",S[H++]="Nullable",S[H++]="Default"),ye>=0&&(S[H++]="Key?"),be>=0&&(S[H++]=
"Definition"),Le>=0&&(S[H++]="FDW options"),De>=0&&(S[H++]="Storage"),he>=0&&(S[H++]=
"Compression"),we>=0&&(S[H++]="Stats target"),He>=0&&(S[H++]="Description"),Ee(H<=
J(S)),We(f,E,b.data,H,Pe),N=!0,c=0;c<H;c++)K(f,S[c],!0,"l");for(c=0;c<Pe;c++){if(U(
f,_(i,c,M),!1,!1),U(f,_(i,c,w),!1,!1),Ce){let g,T,L,I=!1;U(f,_(i,c,se),!1,!1),U(
f,D(_(i,c,ne),"t")==0?"not null":"",!1,!1),g=_(i,c,Ne),T=_(i,c,Qe),g[0]==ha?L="g\
enerated always as identity":g[0]==wa?L="generated by default as identity":T[0]==
Ha?(L=psprintf("generated always as (%s) stored",_(i,c,j)),I=!0):L=_(i,c,j),U(f,
L,!1,I)}if(ye>=0&&U(f,_(i,c,ye),!0,!1),be>=0&&U(f,_(i,c,be),!1,!1),Le>=0&&U(f,_(
i,c,Le),!1,!1),De>=0){let g=_(i,c,De);U(f,g[0]=="p"?"plain":g[0]=="m"?"main":g[0]==
"x"?"extended":g[0]=="e"?"external":"???",!1,!1)}if(he>=0){let g=_(i,c,he);U(f,g[0]==
"p"?"pglz":g[0]=="l"?"lz4":g[0]==r?"":"???",!1,!1)}we>=0&&U(f,_(i,c,we),!1,!1),He>=
0&&U(f,_(i,c,He),!1,!1)}if(m.ispartition){let g;if(d(a,`SELECT inhparent::pg_cat\
alog.regclass,
  pg_catalog.pg_get_expr(c.relpartbound, c.oid),
  `),o(a,p.sversion>=14e4?"inhdetachpending":"false as inhdetachpending"),n&&o(a,
`,
  pg_catalog.pg_get_partition_constraintdef(c.oid)`),u(a,`
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_inherits i ON c.oid = inhrelid
WHERE c.oid = '%s';`,e),g=await O(a.data),!g)return l;if(v(g)>0){let T=_(g,0,0),
L=_(g,0,1),I=_(g,0,2);if(d(y,"Partition of: %s %s%s",T,L,D(I,"t")==0?" DETACH PE\
NDING":""),C(f,y.data),n){let W=r;B(g,0,3)||(W=_(g,0,3)),W==r||W[0]==r?d(y,"No p\
artition constraint"):d(y,"Partition constraint: %s",W),C(f,y.data)}}}if(m.relkind==
$){let g;if(d(a,"SELECT pg_catalog.pg_get_partkeydef('%s'::pg_catalog.oid);",e),
g=await O(a.data),!g)return l;if(v(g)==1){let T=_(g,0,0);d(y,"Partition key: %s",
T),C(f,y.data)}}if(m.relkind==Te){let g;if(d(a,`SELECT n.nspname, c.relname
FROM pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamesp\
ace
WHERE reltoastrelid = '%s';`,e),g=await O(a.data),!g)return l;if(v(g)==1){let T=_(
g,0,0),L=_(g,0,1);d(y,'Owning table: "%s.%s"',T,L),C(f,y.data)}}if(m.relkind==ce||
m.relkind==ae){let g;if(d(a,`SELECT i.indisunique, i.indisprimary, i.indiscluste\
red, i.indisvalid,
  (NOT i.indimmediate) AND EXISTS (SELECT 1 FROM pg_catalog.pg_constraint WHERE \
conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x') A\
ND condeferrable) AS condeferrable,
  (NOT i.indimmediate) AND EXISTS (SELECT 1 FROM pg_catalog.pg_constraint WHERE \
conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x') A\
ND condeferred) AS condeferred,
`),p.sversion>=90400?o(a,`i.indisreplident,
`):o(a,`false AS indisreplident,
`),p.sversion>=15e4?o(a,`i.indnullsnotdistinct,
`):o(a,`false AS indnullsnotdistinct,
`),u(a,`  a.amname, c2.relname, pg_catalog.pg_get_expr(i.indpred, i.indrelid, tr\
ue)
FROM pg_catalog.pg_index i, pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_ca\
talog.pg_am a
WHERE i.indexrelid = c.oid AND c.oid = '%s' AND c.relam = a.oid
AND i.indrelid = c2.oid;`,e),g=await O(a.data),g){if(v(g)!=1)return l;{let T=_(g,
0,0),L=_(g,0,1),I=_(g,0,2),W=_(g,0,3),P=_(g,0,4),le=_(g,0,5),z=_(g,0,6),Se=_(g,0,
7),ga=_(g,0,8),fa=_(g,0,9),Ve=_(g,0,10);D(L,"t")==0?d(y,"primary key, "):D(T,"t")==
0?(d(y,"unique"),D(Se,"t")==0&&o(y," nulls not distinct"),o(y,", ")):Ye(y),u(y,"\
%s, ",ga),u(y,'for table "%s.%s"',t,fa),te(Ve)&&u(y,", predicate (%s)",Ve),D(I,"\
t")==0&&o(y,", clustered"),D(W,"t")!=0&&o(y,", invalid"),D(P,"t")==0&&o(y,", def\
errable"),D(le,"t")==0&&o(y,", initially deferred"),D(z,"t")==0&&o(y,", replica \
identity"),C(f,y.data),m.relkind==ce&&await $e(f,m.relkind,m.tablespace,!0)}}else
return l}else if(m.relkind==Z||m.relkind==G||m.relkind==ee||m.relkind==$||m.relkind==
ae||m.relkind==Te){let g=r,T=0;if(m.hasindex){if(d(a,`SELECT c2.relname, i.indis\
primary, i.indisunique, i.indisclustered, i.indisvalid, pg_catalog.pg_get_indexd\
ef(i.indexrelid, 0, true),
  pg_catalog.pg_get_constraintdef(con.oid, true), contype, condeferrable, condef\
erred`),p.sversion>=90400?o(a,", i.indisreplident"):o(a,", false AS indisreplide\
nt"),o(a,", c2.reltablespace"),u(a,`
FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i
  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid \
= i.indexrelid AND contype IN ('p','u','x'))
WHERE c.oid = '%s' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
ORDER BY i.indisprimary DESC, c2.relname;`,e),g=await O(a.data),g)T=v(g);else return l;
if(T>0)for(C(f,"Indexes:"),c=0;c<T;c++){if(d(a,'    "%s"',_(g,c,0)),D(_(g,c,7),"\
x")==0)u(a," %s",_(g,c,6));else{let L,I;D(_(g,c,1),"t")==0?o(a," PRIMARY KEY,"):
D(_(g,c,2),"t")==0&&(D(_(g,c,7),"u")==0?o(a," UNIQUE CONSTRAINT,"):o(a," UNIQUE,")),
L=_(g,c,5),I=ke(L," USING "),I!=r&&(L=L.slice(I+7)),u(a," %s",L),D(_(g,c,8),"t")==
0&&o(a," DEFERRABLE"),D(_(g,c,9),"t")==0&&o(a," INITIALLY DEFERRED")}D(_(g,c,3),
"t")==0&&o(a," CLUSTER"),D(_(g,c,4),"t")!=0&&o(a," INVALID"),D(_(g,c,10),"t")==0&&
o(a," REPLICA IDENTITY"),C(f,a.data),await $e(f,ce,Je(_(g,c,11)),!1)}}if(m.checks){
if(d(a,`SELECT r.conname, pg_catalog.pg_get_constraintdef(r.oid, true)
FROM pg_catalog.pg_constraint r
WHERE r.conrelid = '%s' AND r.contype = 'c'
ORDER BY 1;`,e),g=await O(a.data),g)T=v(g);else return l;if(T>0)for(C(f,"Check c\
onstraints:"),c=0;c<T;c++)d(a,'    "%s" %s',_(g,c,0),_(g,c,1)),C(f,a.data)}if(m.
hastriggers||m.relkind==$){if(p.sversion>=12e4&&(m.ispartition||m.relkind==$)?d(
a,`SELECT conrelid = '%s'::pg_catalog.regclass AS sametable,
       conname,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef,
       conrelid::pg_catalog.regclass AS ontable
  FROM pg_catalog.pg_constraint,
       pg_catalog.pg_partition_ancestors('%s')
 WHERE conrelid = relid AND contype = 'f' AND conparentid = 0
ORDER BY sametable DESC, conname;`,e,e):(d(a,`SELECT true as sametable, conname,\

  pg_catalog.pg_get_constraintdef(r.oid, true) as condef,
  conrelid::pg_catalog.regclass AS ontable
FROM pg_catalog.pg_constraint r
WHERE r.conrelid = '%s' AND r.contype = 'f'
`,e),p.sversion>=12e4&&o(a,`     AND conparentid = 0
`),o(a,"ORDER BY conname")),g=await O(a.data),g)T=v(g);else return l;if(T>0){let L=ge(
g,"sametable"),I=ge(g,"conname"),W=ge(g,"condef"),P=ge(g,"ontable");for(C(f,"For\
eign-key constraints:"),c=0;c<T;c++)D(_(g,c,L),"f")==0?d(a,'    TABLE "%s" CONST\
RAINT "%s" %s',_(g,c,P),_(g,c,I),_(g,c,W)):d(a,'    "%s" %s',_(g,c,I),_(g,c,W)),
C(f,a.data)}}if(m.hastriggers||m.relkind==$){if(p.sversion>=12e4?d(a,`SELECT con\
name, conrelid::pg_catalog.regclass AS ontable,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint c
 WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('%s')
                     UNION ALL VALUES ('%s'::pg_catalog.regclass))
       AND contype = 'f' AND conparentid = 0
ORDER BY conname;`,e,e):d(a,`SELECT conname, conrelid::pg_catalog.regclass AS on\
table,
       pg_catalog.pg_get_constraintdef(oid, true) AS condef
  FROM pg_catalog.pg_constraint
 WHERE confrelid = %s AND contype = 'f'
ORDER BY conname;`,e),g=await O(a.data),g)T=v(g);else return l;if(T>0){let L=ge(
g,"conname"),I=ge(g,"ontable"),W=ge(g,"condef");for(C(f,"Referenced by:"),c=0;c<
T;c++)d(a,'    TABLE "%s" CONSTRAINT "%s" %s',_(g,c,I),_(g,c,L),_(g,c,W)),C(f,a.
data)}}if(p.sversion>=90500){if(d(a,"SELECT pol.polname,"),p.sversion>=1e5?o(a,`\
 pol.polpermissive,
`):o(a,` 't' as polpermissive,
`),u(a,`  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_stri\
ng(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) \
order by 1),',') END,
  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),
  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),
  CASE pol.polcmd
    WHEN 'r' THEN 'SELECT'
    WHEN 'a' THEN 'INSERT'
    WHEN 'w' THEN 'UPDATE'
    WHEN 'd' THEN 'DELETE'
    END AS cmd
FROM pg_catalog.pg_policy pol
WHERE pol.polrelid = '%s' ORDER BY 1;`,e),g=await O(a.data),g)T=v(g);else return l;
for(m.rowsecurity&&!m.forcerowsecurity&&T>0&&C(f,"Policies:"),m.rowsecurity&&m.forcerowsecurity&&
T>0&&C(f,"Policies (forced row security enabled):"),m.rowsecurity&&!m.forcerowsecurity&&
T==0&&C(f,"Policies (row security enabled): (none)"),m.rowsecurity&&m.forcerowsecurity&&
T==0&&C(f,"Policies (forced row security enabled): (none)"),!m.rowsecurity&&T>0&&
C(f,"Policies (row security disabled):"),c=0;c<T;c++)d(a,'    POLICY "%s"',_(g,c,
0)),_(g,c,1)=="f"&&o(a," AS RESTRICTIVE"),B(g,c,5)||u(a," FOR %s",_(g,c,5)),B(g,
c,2)||u(a,`
      TO %s`,_(g,c,2)),B(g,c,3)||u(a,`
      USING (%s)`,_(g,c,3)),B(g,c,4)||u(a,`
      WITH CHECK (%s)`,_(g,c,4)),C(f,a.data)}if(p.sversion>=14e4){if(d(a,`SELECT\
 oid, stxrelid::pg_catalog.regclass, stxnamespace::pg_catalog.regnamespace::pg_c\
atalog.text AS nsp, stxname,
pg_catalog.pg_get_statisticsobjdef_columns(oid) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
stxstattarget
FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '%s'
ORDER BY nsp, stxname;`,e),g=await O(a.data),g)T=v(g);else return l;if(T>0)for(C(
f,"Statistics objects:"),c=0;c<T;c++){let L=!1,I,W,P,le,z;I=D(_(g,c,5),"t")==0,W=
D(_(g,c,6),"t")==0,P=D(_(g,c,7),"t")==0,d(a,"    "),u(a,'"%s.%s"',_(g,c,2),_(g,c,
3)),le=I&&W&&P,z=I||W||P,z&&!le&&(o(a," ("),I&&(o(a,"ndistinct"),L=!0),W&&(u(a,"\
%sdependencies",L?", ":""),L=!0),P&&u(a,"%smcv",L?", ":""),x(a,")")),u(a," ON %s\
 FROM %s",_(g,c,4),_(g,c,1)),D(_(g,c,8),"-1")!=0&&u(a,"; STATISTICS %s",_(g,c,8)),
C(f,a.data)}}else if(p.sversion>=1e5){if(d(a,`SELECT oid, stxrelid::pg_catalog.r\
egclass, stxnamespace::pg_catalog.regnamespace AS nsp, stxname,
  (SELECT pg_catalog.string_agg(pg_catalog.quote_ident(attname),', ')
   FROM pg_catalog.unnest(stxkeys) s(attnum)
   JOIN pg_catalog.pg_attribute a ON (stxrelid = a.attrelid AND
        a.attnum = s.attnum AND NOT attisdropped)) AS columns,
  'd' = any(stxkind) AS ndist_enabled,
  'f' = any(stxkind) AS deps_enabled,
  'm' = any(stxkind) AS mcv_enabled,
`),p.sversion>=13e4?o(a,`  stxstattarget
`):o(a,`  -1 AS stxstattarget
`),u(a,`FROM pg_catalog.pg_statistic_ext
WHERE stxrelid = '%s'
ORDER BY 1;`,e),g=await O(a.data),g)T=v(g);else return l;if(T>0)for(C(f,"Statist\
ics objects:"),c=0;c<T;c++){let L=!1;d(a,"    "),u(a,'"%s.%s" (',_(g,c,2),_(g,c,
3)),D(_(g,c,5),"t")==0&&(o(a,"ndistinct"),L=!0),D(_(g,c,6),"t")==0&&(u(a,"%sdepe\
ndencies",L?", ":""),L=!0),D(_(g,c,7),"t")==0&&u(a,"%smcv",L?", ":""),u(a,") ON \
%s FROM %s",_(g,c,4),_(g,c,1)),D(_(g,c,8),"-1")!=0&&u(a,"; STATISTICS %s",_(g,c,
8)),C(f,a.data)}}if(m.hasrules&&m.relkind!=G){if(d(a,`SELECT r.rulename, trim(tr\
ailing ';' from pg_catalog.pg_get_ruledef(r.oid, true)), ev_enabled
FROM pg_catalog.pg_rewrite r
WHERE r.ev_class = '%s' ORDER BY 1;`,e),g=await O(a.data),g)T=v(g);else return l;
if(T>0){let L,I;for(I=0;I<4;I++)for(L=!1,c=0;c<T;c++){let W,P=!1;switch(I){case 0:
_(g,c,2)=="O"&&(P=!0);break;case 1:_(g,c,2)=="D"&&(P=!0);break;case 2:_(g,c,2)==
"A"&&(P=!0);break;case 3:_(g,c,2)=="R"&&(P=!0);break}if(P){if(!L){switch(I){case 0:
d(a,"Rules:");break;case 1:d(a,"Disabled rules:");break;case 2:d(a,"Rules firing\
 always:");break;case 3:d(a,"Rules firing on replica only:");break}C(f,a.data),L=
!0}W=_(g,c,1),W=W.slice(12),d(a,"    %s",W),C(f,a.data)}}}}if(p.sversion>=1e5){if(p.
sversion>=15e4?d(a,`SELECT pubname
     , NULL
     , NULL
FROM pg_catalog.pg_publication p
     JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
     JOIN pg_catalog.pg_class pc ON pc.relnamespace = pn.pnnspid
WHERE pc.oid ='%s' and pg_catalog.pg_relation_is_publishable('%s')
UNION
SELECT pubname
     , pg_get_expr(pr.prqual, c.oid)
     , (CASE WHEN pr.prattrs IS NOT NULL THEN
         (SELECT string_agg(attname, ', ')
           FROM pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs:\
:pg_catalog.int2[], 1)) s,
                pg_catalog.pg_attribute
          WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
        ELSE NULL END) FROM pg_catalog.pg_publication p
     JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
     JOIN pg_catalog.pg_class c ON c.oid = pr.prrelid
WHERE pr.prrelid = '%s'
UNION
SELECT pubname
     , NULL
     , NULL
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('%s')
ORDER BY 1;`,e,e,e,e):d(a,`SELECT pubname
     , NULL
     , NULL
FROM pg_catalog.pg_publication p
JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid
WHERE pr.prrelid = '%s'
UNION ALL
SELECT pubname
     , NULL
     , NULL
FROM pg_catalog.pg_publication p
WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('%s')
ORDER BY 1;`,e,e),g=await O(a.data),g)T=v(g);else return l;for(T>0&&C(f,"Publica\
tions:"),c=0;c<T;c++)d(a,'    "%s"',_(g,c,0)),B(g,c,2)||u(a," (%s)",_(g,c,2)),B(
g,c,1)||u(a," WHERE %s",_(g,c,1)),C(f,a.data)}if(n){if(d(a,`SELECT co.conname, a\
t.attname, co.connoinherit, co.conislocal,
co.coninhcount <> 0
FROM pg_catalog.pg_constraint co JOIN
pg_catalog.pg_attribute at ON
(at.attnum = co.conkey[1])
WHERE co.contype = 'n' AND
co.conrelid = '%s'::pg_catalog.regclass AND
at.attrelid = '%s'::pg_catalog.regclass
ORDER BY at.attnum`,e,e),g=await O(a.data),g)T=v(g);else return l;for(T>0&&C(f,"\
Not-null constraints:"),c=0;c<T;c++){let L=_(g,c,3)[0]=="t",I=_(g,c,4)[0]=="t";d(
a,'    "%s" NOT NULL "%s"%s',_(g,c,0),_(g,c,1),_(g,c,2)[0]=="t"?" NO INHERIT":L&&
I?" (local, inherited)":I?" (inherited)":""),C(f,a.data)}}}if((m.relkind==Oe||m.
relkind==G)&&n){let g;if(d(a,"SELECT pg_catalog.pg_get_viewdef('%s'::pg_catalog.\
oid, true);",e),g=await O(a.data),!g)return l;v(g)>0&&(A=_(g,0,0))}if(A){let g=r;
if(C(f,"View definition:"),C(f,A),m.hasrules){if(d(a,`SELECT r.rulename, trim(tr\
ailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))
FROM pg_catalog.pg_rewrite r
WHERE r.ev_class = '%s' AND r.rulename != '_RETURN' ORDER BY 1;`,e),g=await O(a.
data),!g)return l;if(v(g)>0)for(C(f,"Rules:"),c=0;c<v(g);c++){let T;T=_(g,c,1),T=
T.slice(12),d(a," %s",T),C(f,a.data)}}}if(m.hastriggers){let g,T;if(d(a,`SELECT \
t.tgname, pg_catalog.pg_get_triggerdef(t.oid, true), t.tgenabled, t.tgisinternal\
,
`),p.sversion>=13e4?o(a,`  CASE WHEN t.tgparentid != 0 THEN
    (SELECT u.tgrelid::pg_catalog.regclass
     FROM pg_catalog.pg_trigger AS u,
          pg_catalog.pg_partition_ancestors(t.tgrelid) WITH ORDINALITY AS a(reli\
d, depth)
     WHERE u.tgname = t.tgname AND u.tgrelid = a.relid
           AND u.tgparentid = 0
     ORDER BY a.depth LIMIT 1)
  END AS parent
`):o(a,`  NULL AS parent
`),u(a,`FROM pg_catalog.pg_trigger t
WHERE t.tgrelid = '%s' AND `,e),p.sversion>=11e4&&p.sversion<15e4?o(a,`(NOT t.tg\
isinternal OR (t.tgisinternal AND t.tgenabled = 'D') 
    OR EXISTS (SELECT 1 FROM pg_catalog.pg_depend WHERE objid = t.oid 
        AND refclassid = 'pg_catalog.pg_trigger'::pg_catalog.regclass))`):o(a,"(\
NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))"),o(a,`
ORDER BY 1;`),g=await O(a.data),g)T=v(g);else return l;if(T>0){let L,I;for(I=0;I<=
4;I++)for(L=!1,c=0;c<T;c++){let W,P,le,z,Se;switch(z=_(g,c,2),Se=_(g,c,3),W=!1,I){case 0:
(z=="O"||z=="t")&&(W=!0);break;case 1:(z=="D"||z=="f")&&Se=="f"&&(W=!0);break;case 2:
(z=="D"||z=="f")&&Se=="t"&&(W=!0);break;case 3:z=="A"&&(W=!0);break;case 4:z=="R"&&
(W=!0);break}if(W!=!1){if(L==!1){switch(I){case 0:d(a,"Triggers:");break;case 1:
d(a,"Disabled user triggers:");break;case 2:d(a,"Disabled internal triggers:");break;case 3:
d(a,"Triggers firing always:");break;case 4:d(a,"Triggers firing on replica only\
:");break}C(f,a.data),L=!0}P=_(g,c,1),le=ke(P," TRIGGER "),le!=r&&(P=P.slice(le+
9)),d(a,"    %s",P),B(g,c,4)||u(a,", ON TABLE %s",_(g,c,4)),C(f,a.data)}}}}if(m.
relkind==Z||m.relkind==G||m.relkind==ee||m.relkind==$||m.relkind==ae||m.relkind==
Te){let g,T,L;if(g=m.relkind==$||m.relkind==ae,m.relkind==ee){let I;if(d(a,`SELE\
CT s.srvname,
  pg_catalog.array_to_string(ARRAY(
    SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_litera\
l(option_value)
    FROM pg_catalog.pg_options_to_table(ftoptions)),  ', ')
FROM pg_catalog.pg_foreign_table f,
     pg_catalog.pg_foreign_server s
WHERE f.ftrelid = '%s' AND s.oid = f.ftserver;`,e),T=await O(a.data),T){if(v(T)!=
1)return l}else return l;d(a,"Server: %s",_(T,0,0)),C(f,a.data),I=_(T,0,1),I&&I[0]!=
r&&(d(a,"FDW options: (%s)",I),C(f,a.data))}if(d(a,`SELECT c.oid::pg_catalog.reg\
class
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhparent AND i.inhrelid = '%s'
  AND c.relkind != 'p' AND c.relkind != 'I'
ORDER BY inhseqno;`,e),T=await O(a.data),T){let I="Inherits",W=la(I,te(I),p.encoding);
for(L=v(T),c=0;c<L;c++)c==0?d(a,"%s: %s",I,_(T,c,0)):d(a,"%*s  %s",W,"",_(T,c,0)),
c<L-1&&x(a,","),C(f,a.data)}else return l;if(p.sversion>=14e4?d(a,`SELECT c.oid:\
:pg_catalog.regclass, c.relkind, inhdetachpending, pg_catalog.pg_get_expr(c.relp\
artbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '%s'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_ca\
talog.regclass::pg_catalog.text;`,e):p.sversion>=1e5?d(a,`SELECT c.oid::pg_catal\
og.regclass, c.relkind, false AS inhdetachpending, pg_catalog.pg_get_expr(c.relp\
artbound, c.oid)
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '%s'
ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT', c.oid::pg_ca\
talog.regclass::pg_catalog.text;`,e):d(a,`SELECT c.oid::pg_catalog.regclass, c.r\
elkind, false AS inhdetachpending, NULL
FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i
WHERE c.oid = i.inhrelid AND i.inhparent = '%s'
ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;`,e),T=await O(a.data),!T)return l;
if(L=v(T),g&&L==0)d(a,"Number of partitions: %d",L),C(f,a.data);else if(!n)L>0&&
(g?d(a,"Number of partitions: %d (Use \\d+ to list them.)",L):d(a,"Number of chi\
ld tables: %d (Use \\d+ to list them.)",L),C(f,a.data));else{let I=g?"Partitions":
"Child tables",W=la(I,te(I),p.encoding);for(c=0;c<L;c++){let P=_(T,c,1);c==0?d(a,
"%s: %s",I,_(T,c,0)):d(a,"%*s  %s",W,"",_(T,c,0)),B(T,c,3)||u(a," %s",_(T,c,3)),
P==$||P==ae?o(a,", PARTITIONED"):P==ee&&o(a,", FOREIGN"),D(_(T,c,2),"t")==0&&o(a,
" (DETACH PENDING)"),c<L-1&&x(a,","),C(f,a.data)}}if(m.reloftype&&(d(a,"Typed ta\
ble of type: %s",m.reloftype),C(f,a.data)),n&&(m.relkind==Z||m.relkind==G)&&m.relreplident!=
"i"&&(D(t,"pg_catalog")!=0&&m.relreplident!="d"||D(t,"pg_catalog")==0&&m.relreplident!=
"n")){let I="Replica Identity";d(a,"%s: %s",I,m.relreplident=="f"?"FULL":m.relreplident==
"n"?"NOTHING":"???"),C(f,a.data)}n&&m.relkind!=G&&m.hasoids&&C(f,"Has OIDs: yes"),
await $e(f,m.relkind,m.tablespace,!0),n&&m.relam!=r&&!p.hide_tableam&&(d(a,"Acce\
ss method: %s",m.relam),C(f,a.data))}if(n&&m.reloptions&&m.reloptions[0]!=r){let g="\
Options";d(a,"%s: %s",g,m.reloptions),C(f,a.data)}return xe(f,p.queryFout,!1,p.logfile),
l=!0,l}async function $e(t,s,e,n){if((s==Z||s==G||s==ce||s==$||s==ae||s==Te)&&e!=
0){let l=r,a={};if(R(a),d(a,`SELECT spcname FROM pg_catalog.pg_tablespace
WHERE oid = '%u';`,e),l=await O(a.data),!l)return;v(l)>0&&(n?(d(a,'Tablespace: "\
%s"',_(l,0,0)),C(t,a.data)):(d(a,"%s",t.footer),u(a,', tablespace "%s"',_(l,0,0)),
et(t,a.data)))}}async function oa(t,s,e){let n={},l,a={},i=p.popt.topt,E=2,f=0,N,
c,A="l",S;if(i.default_footer=!1,R(n),d(n,`SELECT r.rolname, r.rolsuper, r.rolin\
herit,
  r.rolcreaterole, r.rolcreatedb, r.rolcanlogin,
  r.rolconnlimit, r.rolvaliduntil`),s&&(o(n,`
, pg_catalog.shobj_description(r.oid, 'pg_authid') AS description`),E++),o(n,`
, r.rolreplication`),p.sversion>=90500&&o(n,`
, r.rolbypassrls`),o(n,`
FROM pg_catalog.pg_roles r
`),!e&&!t&&o(n,`WHERE r.rolname !~ '^pg_'
`),!h(n,t,!1,!1,r,"r.rolname",r,r,r,1)||(o(n,"ORDER BY 1;"),l=await O(n.data),!l))
return!1;for(f=v(l),S=[],We(a,i,"List of roles",E,f),K(a,"Role name",!0,A),K(a,"\
Attributes",!0,A),s&&K(a,"Description",!0,A),N=0;N<f;N++)U(a,_(l,N,0),!1,!1),Ye(
n),D(_(l,N,1),"t")==0&&_e(n,"Superuser"),D(_(l,N,2),"t")!=0&&_e(n,"No inheritanc\
e"),D(_(l,N,3),"t")==0&&_e(n,"Create role"),D(_(l,N,4),"t")==0&&_e(n,"Create DB"),
D(_(l,N,5),"t")!=0&&_e(n,"Cannot login"),D(_(l,N,s?9:8),"t")==0&&_e(n,"Replicati\
on"),p.sversion>=90500&&D(_(l,N,s?10:9),"t")==0&&_e(n,"Bypass RLS"),c=Ze(_(l,N,6)),
c>=0&&(n.len>0&&x(n,`
`),c==0?o(n,"No connections"):u(n,ngettext("%d connection","%d connections",c),c)),
D(_(l,N,7),"")!=0&&(n.len>0&&x(n,`
`),o(n,"Password valid until "),o(n,_(l,N,7))),S[N]=n.data,U(a,S[N],!1,!1),s&&U(
a,_(l,N,8),!1,!1);return xe(a,p.queryFout,!1,p.logfile),!0}function _e(t,s){t.len>
0&&o(t,", "),o(t,s)}async function Tt(t,s){let e={},n,l=p.popt,a={};return R(e),
d(e,`SELECT rolname AS "%s", datname AS "%s",
pg_catalog.array_to_string(setconfig, E'\\n') AS "%s"
FROM pg_catalog.pg_db_role_setting s
LEFT JOIN pg_catalog.pg_database d ON d.oid = setdatabase
LEFT JOIN pg_catalog.pg_roles r ON r.oid = setrole
`,"Role","Database","Settings"),!h(e,t,!1,!1,r,"r.rolname",r,r,a,1)||!h(e,s,a.value,
!1,r,"d.datname",r,r,r,1)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),!n)?!1:(v(n)==
0&&!p.quiet?t&&s?k('Did not find any settings for role "%s" and database "%s".',
t,s):t?k('Did not find any settings for role "%s".',t):k("Did not find any setti\
ngs."):(l.nullPrint=r,l.title="List of settings",l.translate_header=!0,F(n,l,p.queryFout,
!1,p.logfile)),!0)}async function Ot(t,s){let e={},n,l=p.popt;return R(e),d(e,`S\
ELECT m.rolname AS "%s", r.rolname AS "%s",
  pg_catalog.concat_ws(', ',
`,"Role name","Member of"),p.sversion>=16e4?o(e,`    CASE WHEN pam.admin_option \
THEN 'ADMIN' END,
    CASE WHEN pam.inherit_option THEN 'INHERIT' END,
    CASE WHEN pam.set_option THEN 'SET' END
`):o(e,`    CASE WHEN pam.admin_option THEN 'ADMIN' END,
    CASE WHEN m.rolinherit THEN 'INHERIT' END,
    'SET'
`),u(e,`  ) AS "%s",
  g.rolname AS "%s"
`,"Options","Grantor"),o(e,`FROM pg_catalog.pg_roles m
     JOIN pg_catalog.pg_auth_members pam ON (pam.member = m.oid)
     LEFT JOIN pg_catalog.pg_roles r ON (pam.roleid = r.oid)
     LEFT JOIN pg_catalog.pg_roles g ON (pam.grantor = g.oid)
`),!s&&!t&&o(e,`WHERE m.rolname !~ '^pg_'
`),!h(e,t,!1,!1,r,"m.rolname",r,r,r,1)||(o(e,`ORDER BY 1, 2, 4;
`),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title="List of role grants",l.translate_header=
!0,F(n,l,p.queryFout,!1,p.logfile),!0)}async function pa(t,s,e,n){let l=q(t,"t")!=
r,a=q(t,"i")!=r,i=q(t,"v")!=r,E=q(t,"m")!=r,f=q(t,"s")!=r,N=q(t,"E")!=r,c={},A,S=p.
popt,b,y=[!1,!1,!0,!1,!1,!1,!1,!1,!1];return l||a||i||E||f||N||(l=i=E=f=N=!0),R(
c),d(c,`SELECT n.nspname as "%s",
  c.relname as "%s",
  CASE c.relkind WHEN 'r' THEN '%s' WHEN 'v' THEN '%s' WHEN 'm' THEN '%s' WHEN '\
i' THEN '%s' WHEN 'S' THEN '%s' WHEN 't' THEN '%s' WHEN 'f' THEN '%s' WHEN 'p' T\
HEN '%s' WHEN 'I' THEN '%s' END as "%s",
  pg_catalog.pg_get_userbyid(c.relowner) as "%s"`,"Schema","Name","table","view",
"materialized view","index","sequence","TOAST table","foreign table","partitione\
d table","partitioned index","Type","Owner"),b=4,a&&(u(c,`,
  c2.relname as "%s"`,"Table"),b++),e&&(u(c,`,
  CASE c.relpersistence WHEN 'p' THEN '%s' WHEN 't' THEN '%s' WHEN 'u' THEN '%s'\
 END as "%s"`,"permanent","temporary","unlogged","Persistence"),y[b]=!0,p.sversion>=
12e4&&!p.hide_tableam&&(l||E||a)&&u(c,`,
  am.amname as "%s"`,"Access method"),u(c,`,
  pg_catalog.pg_size_pretty(pg_catalog.pg_table_size(c.oid)) as "%s",
  pg_catalog.obj_description(c.oid, 'pg_class') as "%s"`,"Size","Description")),
o(c,`
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace`),p.sversion>=
12e4&&!p.hide_tableam&&(l||E||a)&&o(c,`
     LEFT JOIN pg_catalog.pg_am am ON am.oid = c.relam`),a&&o(c,`
     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid`),o(c,`
WHERE c.relkind IN (`),l&&(o(c,"'r','p',"),(n||s)&&o(c,"'t',")),i&&o(c,"'v',"),E&&
o(c,"'m',"),a&&o(c,"'i','I',"),f&&o(c,"'S',"),(n||s)&&o(c,"'s',"),N&&o(c,"'f',"),
o(c,"''"),o(c,`)
`),!n&&!s&&o(c,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname !~ '^pg_toast'
      AND n.nspname <> 'information_schema'
`),!h(c,s,!0,!1,"n.nspname","c.relname",r,"pg_catalog.pg_table_is_visible(c.oid)",
r,3)||(o(c,"ORDER BY 1,2;"),A=await O(c.data),!A)?!1:(v(A)==0&&!p.quiet?s?k('Did\
 not find any relation named "%s".',s):k("Did not find any relations."):(S.nullPrint=
r,S.title="List of relations",S.translate_header=!0,S.translate_columns=y,S.n_translate_columns=
J(y),F(A,S,p.queryFout,!1,p.logfile)),!0)}async function Rt(t,s,e){let n=q(t,"t")!=
r,l=q(t,"i")!=r,a=q(t,"n")!=r,i={},E={},f,N=p.popt,c=[!1,!1,!1,!1,!1,!1,!1,!1,!1],
A,S=!1;if(p.sversion<1e5){let b;return k("The server (version %s) does not suppo\
rt declarative table partitioning.",oe(p.sversion,!1,b,re(b))),!0}return!n&&!l&&
(n=l=!0),l&&!n?A="List of partitioned indexes":n&&!l?A="List of partitioned tabl\
es":(A="List of partitioned relations",S=!0),R(i),d(i,`SELECT n.nspname as "%s",\

  c.relname as "%s",
  pg_catalog.pg_get_userbyid(c.relowner) as "%s"`,"Schema","Name","Owner"),S&&(u(
i,`,
  CASE c.relkind WHEN 'p' THEN '%s' WHEN 'I' THEN '%s' END as "%s"`,"partitioned\
 table","partitioned index","Type"),c[3]=!0),(a||s)&&u(i,`,
  inh.inhparent::pg_catalog.regclass as "%s"`,"Parent name"),l&&u(i,`,
 c2.oid::pg_catalog.regclass as "%s"`,"Table"),e&&(a&&u(i,`,
  s.dps as "%s"`,"Leaf partition size"),u(i,`,
  s.tps as "%s"`,"Total size"),u(i,`,
  pg_catalog.obj_description(c.oid, 'pg_class') as "%s"`,"Description")),o(i,`
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace`),l&&o(i,`
     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid`),(a||s)&&o(i,`
     LEFT JOIN pg_catalog.pg_inherits inh ON c.oid = inh.inhrelid`),e&&(p.sversion<
12e4?o(i,`,
     LATERAL (WITH RECURSIVE d
                AS (SELECT inhrelid AS oid, 1 AS level
                      FROM pg_catalog.pg_inherits
                     WHERE inhparent = c.oid
                    UNION ALL
                    SELECT inhrelid, level + 1
                      FROM pg_catalog.pg_inherits i
                           JOIN d ON i.inhparent = d.oid)
                SELECT pg_catalog.pg_size_pretty(sum(pg_catalog.pg_table_size(d.\
oid))) AS tps,
                       pg_catalog.pg_size_pretty(sum(
             CASE WHEN d.level = 1 THEN pg_catalog.pg_table_size(d.oid) ELSE 0 E\
ND)) AS dps
               FROM d) s`):o(i,`,
     LATERAL (SELECT pg_catalog.pg_size_pretty(sum(
                 CASE WHEN ppt.isleaf AND ppt.level = 1
                      THEN pg_catalog.pg_table_size(ppt.relid) ELSE 0 END)) AS d\
ps,
                     pg_catalog.pg_size_pretty(sum(pg_catalog.pg_table_size(ppt.\
relid))) AS tps
              FROM pg_catalog.pg_partition_tree(c.oid) ppt) s`)),o(i,`
WHERE c.relkind IN (`),n&&o(i,"'p',"),l&&o(i,"'I',"),o(i,"''"),o(i,`)
`),o(i,!a&&!s?` AND NOT c.relispartition
`:""),s||o(i,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname !~ '^pg_toast'
      AND n.nspname <> 'information_schema'
`),!h(i,s,!0,!1,"n.nspname","c.relname",r,"pg_catalog.pg_table_is_visible(c.oid)",
r,3)||(u(i,'ORDER BY "Schema", %s%s"Name";',S?'"Type" DESC, ':"",a||s?'"Parent n\
ame" NULLS FIRST, ':""),f=await O(i.data),!f)?!1:(R(E),o(E,A),N.nullPrint=r,N.title=
E.data,N.translate_header=!0,N.translate_columns=c,N.n_translate_columns=J(c),F(
f,N,p.queryFout,!1,p.logfile),!0)}async function yt(t,s,e){let n={},l,a=p.popt;return R(
n),d(n,`SELECT l.lanname AS "%s",
       pg_catalog.pg_get_userbyid(l.lanowner) as "%s",
       l.lanpltrusted AS "%s"`,"Name","Owner","Trusted"),s&&(u(n,`,
       NOT l.lanispl AS "%s",
       l.lanplcallfoid::pg_catalog.regprocedure AS "%s",
       l.lanvalidator::pg_catalog.regprocedure AS "%s",
       l.laninline::pg_catalog.regprocedure AS "%s",
       `,"Internal language","Call handler","Validator","Inline handler"),V(n,"l\
.lanacl")),u(n,`,
       d.description AS "%s"
FROM pg_catalog.pg_language l
LEFT JOIN pg_catalog.pg_description d
  ON d.classoid = l.tableoid AND d.objoid = l.oid
  AND d.objsubid = 0
`,"Description"),t&&!h(n,t,!1,!1,r,"l.lanname",r,r,r,2)||(!e&&!t&&o(n,`WHERE l.l\
anplcallfoid != 0
`),o(n,"ORDER BY 1;"),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title="List of l\
anguages",a.translate_header=!0,F(l,a,p.queryFout,!1,p.logfile),!0)}async function bt(t,s,e){
let n={},l,a=p.popt;return R(n),d(n,`SELECT n.nspname as "%s",
       t.typname as "%s",
       pg_catalog.format_type(t.typbasetype, t.typtypmod) as "%s",
       (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt
        WHERE c.oid = t.typcollation AND bt.oid = t.typbasetype AND t.typcollati\
on <> bt.typcollation) as "%s",
       CASE WHEN t.typnotnull THEN 'not null' END as "%s",
       t.typdefault as "%s",
       pg_catalog.array_to_string(ARRAY(
         SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM pg_catalog.pg_\
constraint r WHERE t.oid = r.contypid
       ), ' ') as "%s"`,"Schema","Name","Type","Collation","Nullable","Default",
"Check"),s&&(o(n,`,
  `),V(n,"t.typacl"),u(n,`,
       d.description as "%s"`,"Description")),o(n,`
FROM pg_catalog.pg_type t
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
`),s&&o(n,`     LEFT JOIN pg_catalog.pg_description d ON d.classoid = t.tableoid\
 AND d.objoid = t.oid AND d.objsubid = 0
`),o(n,`WHERE t.typtype = 'd'
`),!e&&!t&&o(n,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),!h(n,t,!0,!1,"n.nspname","t.typname",r,"pg_catalog.pg_type_is_visible(t.oid)",
r,3)||(o(n,"ORDER BY 1, 2;"),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title="Li\
st of domains",a.translate_header=!0,F(l,a,p.queryFout,!1,p.logfile),!0)}async function Lt(t,s,e){
let n={},l,a=p.popt,i=[!1,!1,!1,!1,!0,!1];return R(n),d(n,`SELECT n.nspname AS "\
%s",
       c.conname AS "%s",
       pg_catalog.pg_encoding_to_char(c.conforencoding) AS "%s",
       pg_catalog.pg_encoding_to_char(c.contoencoding) AS "%s",
       CASE WHEN c.condefault THEN '%s'
       ELSE '%s' END AS "%s"`,"Schema","Name","Source","Destination","yes","no",
"Default?"),s&&u(n,`,
       d.description AS "%s"`,"Description"),o(n,`
FROM pg_catalog.pg_conversion c
     JOIN pg_catalog.pg_namespace n ON n.oid = c.connamespace
`),s&&o(n,`LEFT JOIN pg_catalog.pg_description d ON d.classoid = c.tableoid
          AND d.objoid = c.oid AND d.objsubid = 0
`),o(n,`WHERE true
`),!e&&!t&&o(n,`  AND n.nspname <> 'pg_catalog'
  AND n.nspname <> 'information_schema'
`),!h(n,t,!0,!1,"n.nspname","c.conname",r,"pg_catalog.pg_conversion_is_visible(c\
.oid)",r,3)||(o(n,"ORDER BY 1, 2;"),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title=
"List of conversions",a.translate_header=!0,a.translate_columns=i,a.n_translate_columns=
J(i),F(l,a,p.queryFout,!1,p.logfile),!0)}async function Dt(t,s,e){let n={},l,a=p.
popt;return R(n),d(n,'SELECT s.name AS "%s", pg_catalog.current_setting(s.name) \
AS "%s"',"Parameter","Value"),s&&(u(n,', s.vartype AS "%s", s.context AS "%s", ',
"Type","Context"),p.sversion>=15e4?V(n,"p.paracl"):u(n,'NULL AS "%s"',"Access pr\
ivileges")),o(n,`
FROM pg_catalog.pg_settings s
`),s&&p.sversion>=15e4&&o(n,`  LEFT JOIN pg_catalog.pg_parameter_acl p
  ON pg_catalog.lower(s.name) = p.parname
`),t?ia(p.db,n,t,!1,!1,r,"pg_catalog.lower(s.name)",r,r,r,r):o(n,`WHERE s.source\
 <> 'default' AND
      s.setting IS DISTINCT FROM s.boot_val
`),o(n,"ORDER BY 1;"),l=await O(n.data),l?(a.nullPrint=r,t?a.title="List of conf\
iguration parameters":a.title="List of non-default configuration parameters",a.translate_header=
!0,F(l,a,p.queryFout,!1,p.logfile),!0):!1}async function ht(t,s){let e={},n,l=p.
popt,a=[!1,!1,!1,!0,!1,!1,!1];if(p.sversion<90300){let i;return k("The server (v\
ersion %s) does not support event triggers.",oe(p.sversion,!1,i,re(i))),!0}return R(
e),d(e,`SELECT evtname as "%s", evtevent as "%s", pg_catalog.pg_get_userbyid(e.e\
vtowner) as "%s",
 case evtenabled when 'O' then '%s'  when 'R' then '%s'  when 'A' then '%s'  whe\
n 'D' then '%s' end as "%s",
 e.evtfoid::pg_catalog.regproc as "%s", pg_catalog.array_to_string(array(select \
x from pg_catalog.unnest(evttags) as t(x)), ', ') as "%s"`,"Name","Event","Owner",
"enabled","replica","always","disabled","Enabled","Function","Tags"),s&&u(e,`,
pg_catalog.obj_description(e.oid, 'pg_event_trigger') as "%s"`,"Description"),o(
e,`
FROM pg_catalog.pg_event_trigger e `),!h(e,t,!1,!1,r,"evtname",r,r,r,1)||(o(e,"O\
RDER BY 1"),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title="List of event trigg\
ers",l.translate_header=!0,l.translate_columns=a,l.n_translate_columns=J(a),F(n,
l,p.queryFout,!1,p.logfile),!0)}async function wt(t){let s={},e,n=p.popt;if(p.sversion<
1e5){let l;return k("The server (version %s) does not support extended statistic\
s.",oe(p.sversion,!1,l,re(l))),!0}return R(s),d(s,`SELECT 
es.stxnamespace::pg_catalog.regnamespace::pg_catalog.text AS "%s", 
es.stxname AS "%s", 
`,"Schema","Name"),p.sversion>=14e4?u(s,`pg_catalog.format('%%s FROM %%s', 
  pg_catalog.pg_get_statisticsobjdef_columns(es.oid), 
  es.stxrelid::pg_catalog.regclass) AS "%s"`,"Definition"):u(s,`pg_catalog.forma\
t('%%s FROM %%s', 
  (SELECT pg_catalog.string_agg(pg_catalog.quote_ident(a.attname),', ') 
   FROM pg_catalog.unnest(es.stxkeys) s(attnum) 
   JOIN pg_catalog.pg_attribute a 
   ON (es.stxrelid = a.attrelid 
   AND a.attnum = s.attnum 
   AND NOT a.attisdropped)), 
es.stxrelid::pg_catalog.regclass) AS "%s"`,"Definition"),u(s,`,
CASE WHEN 'd' = any(es.stxkind) THEN 'defined' 
END AS "%s", 
CASE WHEN 'f' = any(es.stxkind) THEN 'defined' 
END AS "%s"`,"Ndistinct","Dependencies"),p.sversion>=12e4&&u(s,`,
CASE WHEN 'm' = any(es.stxkind) THEN 'defined' 
END AS "%s" `,"MCV"),o(s,` 
FROM pg_catalog.pg_statistic_ext es 
`),!h(s,t,!1,!1,"es.stxnamespace::pg_catalog.regnamespace::pg_catalog.text","es.\
stxname",r,"pg_catalog.pg_statistics_obj_is_visible(es.oid)",r,3)||(o(s,"ORDER B\
Y 1, 2;"),e=await O(s.data),!e)?!1:(n.nullPrint=r,n.title="List of extended stat\
istics",n.translate_header=!0,F(e,n,p.queryFout,!1,p.logfile),!0)}async function Ht(t,s){
let e={},n,l=p.popt,a=[!1,!1,!1,!0,!1];return R(e),d(e,`SELECT pg_catalog.format\
_type(castsource, NULL) AS "%s",
       pg_catalog.format_type(casttarget, NULL) AS "%s",
`,"Source type","Target type"),u(e,`       CASE WHEN c.castmethod = '%c' THEN '(\
binary coercible)'
            WHEN c.castmethod = '%c' THEN '(with inout)'
            ELSE p.proname
       END AS "%s",
`,Sa,Aa,"Function"),u(e,`       CASE WHEN c.castcontext = '%c' THEN '%s'
            WHEN c.castcontext = '%c' THEN '%s'
            ELSE '%s'
       END AS "%s"`,Oa,"no",Ta,"in assignment","yes","Implicit?"),s&&u(e,`,
       d.description AS "%s"`,"Description"),o(e,`
FROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p
     ON c.castfunc = p.oid
     LEFT JOIN pg_catalog.pg_type ts
     ON c.castsource = ts.oid
     LEFT JOIN pg_catalog.pg_namespace ns
     ON ns.oid = ts.typnamespace
     LEFT JOIN pg_catalog.pg_type tt
     ON c.casttarget = tt.oid
     LEFT JOIN pg_catalog.pg_namespace nt
     ON nt.oid = tt.typnamespace
`),s&&o(e,`     LEFT JOIN pg_catalog.pg_description d
     ON d.classoid = c.tableoid AND d.objoid = c.oid AND d.objsubid = 0
`),o(e,"WHERE ( (true"),!h(e,t,!0,!1,"ns.nspname","ts.typname","pg_catalog.forma\
t_type(ts.oid, NULL)","pg_catalog.pg_type_is_visible(ts.oid)",r,3)||(o(e,") OR (\
true"),!h(e,t,!0,!1,"nt.nspname","tt.typname","pg_catalog.format_type(tt.oid, NU\
LL)","pg_catalog.pg_type_is_visible(tt.oid)",r,3))||(o(e,`) )
ORDER BY 1, 2;`),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title="List of casts",
l.translate_header=!0,l.translate_columns=a,l.n_translate_columns=J(a),F(n,l,p.queryFout,
!1,p.logfile),!0)}async function Ct(t,s,e){let n={},l,a=p.popt,i=[!1,!1,!1,!1,!1,
!1,!1,!0,!1];return R(n),d(n,`SELECT
  n.nspname AS "%s",
  c.collname AS "%s",
`,"Schema","Name"),p.sversion>=1e5?u(n,`  CASE c.collprovider WHEN 'd' THEN 'def\
ault' WHEN 'c' THEN 'libc' WHEN 'i' THEN 'icu' END AS "%s",
`,"Provider"):u(n,`  'libc' AS "%s",
`,"Provider"),u(n,`  c.collcollate AS "%s",
  c.collctype AS "%s",
`,"Collate","Ctype"),p.sversion>=15e4?u(n,`  c.colliculocale AS "%s",
`,"ICU Locale"):u(n,`  c.collcollate AS "%s",
`,"ICU Locale"),p.sversion>=16e4?u(n,`  c.collicurules AS "%s",
`,"ICU Rules"):u(n,`  NULL AS "%s",
`,"ICU Rules"),p.sversion>=12e4?u(n,`  CASE WHEN c.collisdeterministic THEN '%s'\
 ELSE '%s' END AS "%s"`,"yes","no","Deterministic?"):u(n,`  '%s' AS "%s"`,"yes",
"Deterministic?"),s&&u(n,`,
  pg_catalog.obj_description(c.oid, 'pg_collation') AS "%s"`,"Description"),o(n,
`
FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n
WHERE n.oid = c.collnamespace
`),!e&&!t&&o(n,`      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
`),o(n,`      AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catal\
og.getdatabaseencoding()))
`),!h(n,t,!0,!1,"n.nspname","c.collname",r,"pg_catalog.pg_collation_is_visible(c\
.oid)",r,3)||(o(n,"ORDER BY 1, 2;"),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title=
"List of collations",a.translate_header=!0,a.translate_columns=i,a.n_translate_columns=
J(i),F(l,a,p.queryFout,!1,p.logfile),!0)}async function It(t,s,e){let n={},l,a=p.
popt,i=0,E=r;if(R(n),d(n,`SELECT n.nspname AS "%s",
  pg_catalog.pg_get_userbyid(n.nspowner) AS "%s"`,"Name","Owner"),s&&(o(n,`,
  `),V(n,"n.nspacl"),u(n,`,
  pg_catalog.obj_description(n.oid, 'pg_namespace') AS "%s"`,"Description")),o(n,
`
FROM pg_catalog.pg_namespace n
`),!e&&!t&&o(n,`WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema'
`),!h(n,t,!e&&!t,!1,r,"n.nspname",r,r,r,2)||(o(n,"ORDER BY 1;"),l=await O(n.data),
!l))return!1;if(a.nullPrint=r,a.title="List of schemas",a.translate_header=!0,t&&
p.sversion>=15e4){let f,N;if(d(n,`SELECT pubname 
FROM pg_catalog.pg_publication p
     JOIN pg_catalog.pg_publication_namespace pn ON p.oid = pn.pnpubid
     JOIN pg_catalog.pg_namespace n ON n.oid = pn.pnnspid 
WHERE n.nspname = '%s'
ORDER BY 1`,t),f=await O(n.data),f)i=v(f);else return!1;if(i>0){for(E=[],E[0]="P\
ublications:",N=0;N<i;N++)d(n,'    "%s"',_(f,N,0)),E[N+1]=n.data;E[N+1]=r,a.footers=
E}}return F(l,a,p.queryFout,!1,p.logfile),!0}async function Ft(t,s){let e={},n,l=p.
popt;return s?await vt(t):(R(e),d(e,`SELECT
  n.nspname as "%s",
  p.prsname as "%s",
  pg_catalog.obj_description(p.oid, 'pg_ts_parser') as "%s"
FROM pg_catalog.pg_ts_parser p
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace
`,"Schema","Name","Description"),!h(e,t,!1,!1,"n.nspname","p.prsname",r,"pg_cata\
log.pg_ts_parser_is_visible(p.oid)",r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),
!n)?!1:(l.nullPrint=r,l.title="List of text search parsers",l.translate_header=!0,
F(n,l,p.queryFout,!1,p.logfile),!0))}async function vt(t){let s={},e,n;if(R(s),d(
s,`SELECT p.oid,
  n.nspname,
  p.prsname
FROM pg_catalog.pg_ts_parser p
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace
`),!h(s,t,!1,!1,"n.nspname","p.prsname",r,"pg_catalog.pg_ts_parser_is_visible(p.\
oid)",r,3)||(o(s,"ORDER BY 1, 2;"),e=await O(s.data),!e))return!1;if(v(e)==0)return p.
quiet||(t?k('Did not find any text search parser named "%s".',t):k("Did not find\
 any text search parsers.")),!1;for(n=0;n<v(e);n++){let l,a=r,i;if(l=_(e,n,0),B(
e,n,1)||(a=_(e,n,1)),i=_(e,n,2),!await kt(l,a,i)||Ie)return!1}return!0}async function kt(t,s,e){
let n={},l,a={},i=p.popt,E=[!0,!1,!1];return R(n),d(n,`SELECT '%s' AS "%s",
   p.prsstart::pg_catalog.regproc AS "%s",
   pg_catalog.obj_description(p.prsstart, 'pg_proc') as "%s"
 FROM pg_catalog.pg_ts_parser p
 WHERE p.oid = '%s'
UNION ALL
SELECT '%s',
   p.prstoken::pg_catalog.regproc,
   pg_catalog.obj_description(p.prstoken, 'pg_proc')
 FROM pg_catalog.pg_ts_parser p
 WHERE p.oid = '%s'
UNION ALL
SELECT '%s',
   p.prsend::pg_catalog.regproc,
   pg_catalog.obj_description(p.prsend, 'pg_proc')
 FROM pg_catalog.pg_ts_parser p
 WHERE p.oid = '%s'
UNION ALL
SELECT '%s',
   p.prsheadline::pg_catalog.regproc,
   pg_catalog.obj_description(p.prsheadline, 'pg_proc')
 FROM pg_catalog.pg_ts_parser p
 WHERE p.oid = '%s'
UNION ALL
SELECT '%s',
   p.prslextype::pg_catalog.regproc,
   pg_catalog.obj_description(p.prslextype, 'pg_proc')
 FROM pg_catalog.pg_ts_parser p
 WHERE p.oid = '%s';`,"Start parse","Method","Function","Description",t,"Get nex\
t token",t,"End parse",t,"Get headline",t,"Get token types",t),l=await O(n.data),
!l||(i.nullPrint=r,R(a),s?d(a,'Text search parser "%s.%s"',s,e):d(a,'Text search\
 parser "%s"',e),i.title=a.data,i.footers=r,i.topt.default_footer=!1,i.translate_header=
!0,i.translate_columns=E,i.n_translate_columns=J(E),F(l,i,p.queryFout,!1,p.logfile),
R(n),d(n,`SELECT t.alias as "%s",
  t.description as "%s"
FROM pg_catalog.ts_token_type( '%s'::pg_catalog.oid ) as t
ORDER BY 1;`,"Token name","Description",t),l=await O(n.data),!l)?!1:(i.nullPrint=
r,s?d(a,'Token types for parser "%s.%s"',s,e):d(a,'Token types for parser "%s"',
e),i.title=a.data,i.footers=r,i.topt.default_footer=!0,i.translate_header=!0,i.translate_columns=
r,i.n_translate_columns=0,F(l,i,p.queryFout,!1,p.logfile),!0)}async function Wt(t,s){
let e={},n,l=p.popt;return R(e),d(e,`SELECT
  n.nspname as "%s",
  d.dictname as "%s",
`,"Schema","Name"),s&&u(e,`  ( SELECT COALESCE(nt.nspname, '(null)')::pg_catalog\
.text || '.' || t.tmplname FROM
    pg_catalog.pg_ts_template t
    LEFT JOIN pg_catalog.pg_namespace nt ON nt.oid = t.tmplnamespace
    WHERE d.dicttemplate = t.oid ) AS  "%s",
  d.dictinitoption as "%s",
`,"Template","Init options"),u(e,`  pg_catalog.obj_description(d.oid, 'pg_ts_dic\
t') as "%s"
`,"Description"),o(e,`FROM pg_catalog.pg_ts_dict d
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace
`),!h(e,t,!1,!1,"n.nspname","d.dictname",r,"pg_catalog.pg_ts_dict_is_visible(d.o\
id)",r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title=
"List of text search dictionaries",l.translate_header=!0,F(n,l,p.queryFout,!1,p.
logfile),!0)}async function xt(t,s){let e={},n,l=p.popt;return R(e),s?d(e,`SELEC\
T
  n.nspname AS "%s",
  t.tmplname AS "%s",
  t.tmplinit::pg_catalog.regproc AS "%s",
  t.tmpllexize::pg_catalog.regproc AS "%s",
  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS "%s"
`,"Schema","Name","Init","Lexize","Description"):d(e,`SELECT
  n.nspname AS "%s",
  t.tmplname AS "%s",
  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS "%s"
`,"Schema","Name","Description"),o(e,`FROM pg_catalog.pg_ts_template t
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace
`),!h(e,t,!1,!1,"n.nspname","t.tmplname",r,"pg_catalog.pg_ts_template_is_visible\
(t.oid)",r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.
title="List of text search templates",l.translate_header=!0,F(n,l,p.queryFout,!1,
p.logfile),!0)}async function Pt(t,s){let e={},n,l=p.popt;return s?await Mt(t):(R(
e),d(e,`SELECT
   n.nspname as "%s",
   c.cfgname as "%s",
   pg_catalog.obj_description(c.oid, 'pg_ts_config') as "%s"
FROM pg_catalog.pg_ts_config c
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace
`,"Schema","Name","Description"),!h(e,t,!1,!1,"n.nspname","c.cfgname",r,"pg_cata\
log.pg_ts_config_is_visible(c.oid)",r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),
!n)?!1:(l.nullPrint=r,l.title="List of text search configurations",l.translate_header=
!0,F(n,l,p.queryFout,!1,p.logfile),!0))}async function Mt(t){let s={},e,n;if(R(s),
d(s,`SELECT c.oid, c.cfgname,
   n.nspname,
   p.prsname,
   np.nspname as pnspname
FROM pg_catalog.pg_ts_config c
   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace,
 pg_catalog.pg_ts_parser p
   LEFT JOIN pg_catalog.pg_namespace np ON np.oid = p.prsnamespace
WHERE  p.oid = c.cfgparser
`),!h(s,t,!0,!1,"n.nspname","c.cfgname",r,"pg_catalog.pg_ts_config_is_visible(c.\
oid)",r,3)||(o(s,"ORDER BY 3, 2;"),e=await O(s.data),!e))return!1;if(v(e)==0)return p.
quiet||(t?k('Did not find any text search configuration named "%s".',t):k("Did n\
ot find any text search configurations.")),!1;for(n=0;n<v(e);n++){let l,a,i=r,E,
f=r;if(l=_(e,n,0),a=_(e,n,1),B(e,n,2)||(i=_(e,n,2)),E=_(e,n,3),B(e,n,4)||(f=_(e,
n,4)),!await Ut(l,i,a,f,E)||Ie)return!1}return!0}async function Ut(t,s,e,n,l){let a={},
i={},E,f=p.popt;return R(a),d(a,`SELECT
  ( SELECT t.alias FROM
    pg_catalog.ts_token_type(c.cfgparser) AS t
    WHERE t.tokid = m.maptokentype ) AS "%s",
  pg_catalog.btrim(
    ARRAY( SELECT mm.mapdict::pg_catalog.regdictionary
           FROM pg_catalog.pg_ts_config_map AS mm
           WHERE mm.mapcfg = m.mapcfg AND mm.maptokentype = m.maptokentype
           ORDER BY mapcfg, maptokentype, mapseqno
    ) :: pg_catalog.text,
  '{}') AS "%s"
FROM pg_catalog.pg_ts_config AS c, pg_catalog.pg_ts_config_map AS m
WHERE c.oid = '%s' AND m.mapcfg = c.oid
GROUP BY m.mapcfg, m.maptokentype, c.cfgparser
ORDER BY 1;`,"Token","Dictionaries",t),E=await O(a.data),E?(R(i),s?u(i,'Text sea\
rch configuration "%s.%s"',s,e):u(i,'Text search configuration "%s"',e),n?u(i,`
Parser: "%s.%s"`,n,l):u(i,`
Parser: "%s"`,l),f.nullPrint=r,f.title=i.data,f.footers=r,f.topt.default_footer=
!1,f.translate_header=!0,F(E,f,p.queryFout,!1,p.logfile),!0):!1}async function qt(t,s){
let e={},n,l=p.popt;return R(e),d(e,`SELECT fdw.fdwname AS "%s",
  pg_catalog.pg_get_userbyid(fdw.fdwowner) AS "%s",
  fdw.fdwhandler::pg_catalog.regproc AS "%s",
  fdw.fdwvalidator::pg_catalog.regproc AS "%s"`,"Name","Owner","Handler","Valida\
tor"),s&&(o(e,`,
  `),V(e,"fdwacl"),u(e,`,
 CASE WHEN fdwoptions IS NULL THEN '' ELSE   '(' || pg_catalog.array_to_string(A\
RRAY(SELECT   pg_catalog.quote_ident(option_name) ||  ' ' ||   pg_catalog.quote_\
literal(option_value)  FROM   pg_catalog.pg_options_to_table(fdwoptions)),  ', '\
) || ')'   END AS "%s",
  d.description AS "%s" `,"FDW options","Description")),o(e,`
FROM pg_catalog.pg_foreign_data_wrapper fdw
`),s&&o(e,`LEFT JOIN pg_catalog.pg_description d
       ON d.classoid = fdw.tableoid AND d.objoid = fdw.oid AND d.objsubid = 0
`),!h(e,t,!1,!1,r,"fdwname",r,r,r,1)||(o(e,"ORDER BY 1;"),n=await O(e.data),!n)?
!1:(l.nullPrint=r,l.title="List of foreign-data wrappers",l.translate_header=!0,
F(n,l,p.queryFout,!1,p.logfile),!0)}async function Jt(t,s){let e={},n,l=p.popt;return R(
e),d(e,`SELECT s.srvname AS "%s",
  pg_catalog.pg_get_userbyid(s.srvowner) AS "%s",
  f.fdwname AS "%s"`,"Name","Owner","Foreign-data wrapper"),s&&(o(e,`,
  `),V(e,"s.srvacl"),u(e,`,
  s.srvtype AS "%s",
  s.srvversion AS "%s",
  CASE WHEN srvoptions IS NULL THEN '' ELSE   '(' || pg_catalog.array_to_string(\
ARRAY(SELECT   pg_catalog.quote_ident(option_name) ||  ' ' ||   pg_catalog.quote\
_literal(option_value)  FROM   pg_catalog.pg_options_to_table(srvoptions)),  ', \
') || ')'   END AS "%s",
  d.description AS "%s"`,"Type","Version","FDW options","Description")),o(e,`
FROM pg_catalog.pg_foreign_server s
     JOIN pg_catalog.pg_foreign_data_wrapper f ON f.oid=s.srvfdw
`),s&&o(e,`LEFT JOIN pg_catalog.pg_description d
       ON d.classoid = s.tableoid AND d.objoid = s.oid AND d.objsubid = 0
`),!h(e,t,!1,!1,r,"s.srvname",r,r,r,1)||(o(e,"ORDER BY 1;"),n=await O(e.data),!n)?
!1:(l.nullPrint=r,l.title="List of foreign servers",l.translate_header=!0,F(n,l,
p.queryFout,!1,p.logfile),!0)}async function Yt(t,s){let e={},n,l=p.popt;return R(
e),d(e,`SELECT um.srvname AS "%s",
  um.usename AS "%s"`,"Server","User name"),s&&u(e,`,
 CASE WHEN umoptions IS NULL THEN '' ELSE   '(' || pg_catalog.array_to_string(AR\
RAY(SELECT   pg_catalog.quote_ident(option_name) ||  ' ' ||   pg_catalog.quote_l\
iteral(option_value)  FROM   pg_catalog.pg_options_to_table(umoptions)),  ', ') \
|| ')'   END AS "%s"`,"FDW options"),o(e,`
FROM pg_catalog.pg_user_mappings um
`),!h(e,t,!1,!1,r,"um.srvname","um.usename",r,r,1)||(o(e,"ORDER BY 1, 2;"),n=await O(
e.data),!n)?!1:(l.nullPrint=r,l.title="List of user mappings",l.translate_header=
!0,F(n,l,p.queryFout,!1,p.logfile),!0)}async function Bt(t,s){let e={},n,l=p.popt;
return R(e),d(e,`SELECT n.nspname AS "%s",
  c.relname AS "%s",
  s.srvname AS "%s"`,"Schema","Table","Server"),s&&u(e,`,
 CASE WHEN ftoptions IS NULL THEN '' ELSE   '(' || pg_catalog.array_to_string(AR\
RAY(SELECT   pg_catalog.quote_ident(option_name) ||  ' ' ||   pg_catalog.quote_l\
iteral(option_value)  FROM   pg_catalog.pg_options_to_table(ftoptions)),  ', ') \
|| ')'   END AS "%s",
  d.description AS "%s"`,"FDW options","Description"),o(e,`
FROM pg_catalog.pg_foreign_table ft
  INNER JOIN pg_catalog.pg_class c ON c.oid = ft.ftrelid
  INNER JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
  INNER JOIN pg_catalog.pg_foreign_server s ON s.oid = ft.ftserver
`),s&&o(e,`   LEFT JOIN pg_catalog.pg_description d
          ON d.classoid = c.tableoid AND d.objoid = c.oid AND d.objsubid = 0
`),!h(e,t,!1,!1,"n.nspname","c.relname",r,"pg_catalog.pg_table_is_visible(c.oid)",
r,3)||(o(e,"ORDER BY 1, 2;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,l.title="Li\
st of foreign tables",l.translate_header=!0,F(n,l,p.queryFout,!1,p.logfile),!0)}
async function jt(t){let s={},e,n=p.popt;return R(s),d(s,`SELECT e.extname AS "%\
s", e.extversion AS "%s", n.nspname AS "%s", c.description AS "%s"
FROM pg_catalog.pg_extension e LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.\
extnamespace LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid AND c.cla\
ssoid = 'pg_catalog.pg_extension'::pg_catalog.regclass
`,"Name","Version","Schema","Description"),!h(s,t,!1,!1,r,"e.extname",r,r,r,1)||
(o(s,"ORDER BY 1;"),e=await O(s.data),!e)?!1:(n.nullPrint=r,n.title="List of ins\
talled extensions",n.translate_header=!0,F(e,n,p.queryFout,!1,p.logfile),!0)}async function zt(t){
let s={},e,n;if(R(s),d(s,`SELECT e.extname, e.oid
FROM pg_catalog.pg_extension e
`),!h(s,t,!1,!1,r,"e.extname",r,r,r,1)||(o(s,"ORDER BY 1;"),e=await O(s.data),!e))
return!1;if(v(e)==0)return p.quiet||(t?k('Did not find any extension named "%s".',
t):k("Did not find any extensions.")),!1;for(n=0;n<v(e);n++){let l,a;if(l=_(e,n,
0),a=_(e,n,1),!await $t(l,a)||Ie)return!1}return!0}async function $t(t,s){let e={},
n,l={},a=p.popt;return R(e),d(e,`SELECT pg_catalog.pg_describe_object(classid, o\
bjid, 0) AS "%s"
FROM pg_catalog.pg_depend
WHERE refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass AND refobjid =\
 '%s' AND deptype = 'e'
ORDER BY 1;`,"Object description",s),n=await O(e.data),n?(a.nullPrint=r,R(l),d(l,
'Objects in extension "%s"',t),a.title=l.data,a.translate_header=!0,F(n,a,p.queryFout,
!1,p.logfile),!0):!1}async function Qt(t){let s={},e,n=p.popt,l=[!1,!1,!1,!1,!1,
!1,!1,!1];if(p.sversion<1e5){let a;return k("The server (version %s) does not su\
pport publications.",oe(p.sversion,!1,a,re(a))),!0}return R(s),d(s,`SELECT pubna\
me AS "%s",
  pg_catalog.pg_get_userbyid(pubowner) AS "%s",
  puballtables AS "%s",
  pubinsert AS "%s",
  pubupdate AS "%s",
  pubdelete AS "%s"`,"Name","Owner","All tables","Inserts","Updates","Deletes"),
p.sversion>=11e4&&u(s,`,
  pubtruncate AS "%s"`,"Truncates"),p.sversion>=13e4&&u(s,`,
  pubviaroot AS "%s"`,"Via root"),o(s,`
FROM pg_catalog.pg_publication
`),!h(s,t,!1,!1,r,"pubname",r,r,r,1)||(o(s,"ORDER BY 1;"),e=await O(s.data),!e)?
!1:(n.nullPrint=r,n.title="List of publications",n.translate_header=!0,n.translate_columns=
l,n.n_translate_columns=J(l),F(e,n,p.queryFout,!1,p.logfile),!0)}async function ca(t,s,e,n){
let l,a=0,i=0;if(l=await O(t.data),l)a=v(l);else return!1;for(a>0&&C(n,s),i=0;i<
a;i++)e?d(t,'    "%s"',_(l,i,0)):(d(t,'    "%s.%s"',_(l,i,0),_(l,i,1)),B(l,i,3)||
u(t," (%s)",_(l,i,3)),B(l,i,2)||u(t," WHERE %s",_(l,i,2))),C(n,t.data);return!0}
async function Vt(t){let s={},e,n,l,a,i={},E={};if(p.sversion<1e5){let f;return k(
"The server (version %s) does not support publications.",oe(p.sversion,!1,f,re(f))),
!0}if(l=p.sversion>=11e4,a=p.sversion>=13e4,R(s),d(s,`SELECT oid, pubname,
  pg_catalog.pg_get_userbyid(pubowner) AS owner,
  puballtables, pubinsert, pubupdate, pubdelete`),l&&o(s,", pubtruncate"),a&&o(s,
", pubviaroot"),o(s,`
FROM pg_catalog.pg_publication
`),!h(s,t,!1,!1,r,"pubname",r,r,r,1)||(o(s,"ORDER BY 2;"),n=await O(s.data),!n))
return!1;if(v(n)==0)return p.quiet||(t?k('Did not find any publication named "%s\
".',t):k("Did not find any publications.")),!1;for(e=0;e<v(n);e++){let f="l",N=5,
c=1,A=_(n,e,0),S=_(n,e,1),b=D(_(n,e,3),"t")==0,y=p.popt.topt;if(l&&N++,a&&N++,R(
i),d(i,"Publication %s",S),We(E,y,i.data,N,c),K(E,"Owner",!0,f),K(E,"All tables",
!0,f),K(E,"Inserts",!0,f),K(E,"Updates",!0,f),K(E,"Deletes",!0,f),l&&K(E,"Trunca\
tes",!0,f),a&&K(E,"Via root",!0,f),U(E,_(n,e,2),!1,!1),U(E,_(n,e,3),!1,!1),U(E,_(
n,e,4),!1,!1),U(E,_(n,e,5),!1,!1),U(E,_(n,e,6),!1,!1),l&&U(E,_(n,e,7),!1,!1),a&&
U(E,_(n,e,8),!1,!1),!b&&(d(s,"SELECT n.nspname, c.relname"),p.sversion>=15e4?(o(
s,", pg_get_expr(pr.prqual, c.oid)"),o(s,`, (CASE WHEN pr.prattrs IS NOT NULL TH\
EN
     pg_catalog.array_to_string(      ARRAY(SELECT attname
              FROM
                pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs:\
:pg_catalog.int2[], 1)) s,
                pg_catalog.pg_attribute
        WHERE attrelid = c.oid AND attnum = prattrs[s]), ', ')
       ELSE NULL END)`)):o(s,", NULL, NULL"),u(s,`
FROM pg_catalog.pg_class c,
     pg_catalog.pg_namespace n,
     pg_catalog.pg_publication_rel pr
WHERE c.relnamespace = n.oid
  AND c.oid = pr.prrelid
  AND pr.prpubid = '%s'
ORDER BY 1,2`,A),!await ca(s,"Tables:",!1,E)||p.sversion>=15e4&&(d(s,`SELECT n.n\
spname
FROM pg_catalog.pg_namespace n
     JOIN pg_catalog.pg_publication_namespace pn ON n.oid = pn.pnnspid
WHERE pn.pnpubid = '%s'
ORDER BY 1`,A),!await ca(s,"Tables from schemas:",!0,E))))return!1;xe(E,p.queryFout,
!1,p.logfile)}return!0}async function Gt(t,s){let e={},n,l=p.popt,a=[!1,!1,!1,!1,
!1,!1,!1,!1,!1,!1,!1,!1,!1,!1];if(p.sversion<1e5){let i;return k("The server (ve\
rsion %s) does not support subscriptions.",oe(p.sversion,!1,i,re(i))),!0}return R(
e),d(e,`SELECT subname AS "%s"
,  pg_catalog.pg_get_userbyid(subowner) AS "%s"
,  subenabled AS "%s"
,  subpublications AS "%s"
`,"Name","Owner","Enabled","Publication"),s&&(p.sversion>=14e4&&(u(e,`, subbinar\
y AS "%s"
`,"Binary"),p.sversion>=16e4?u(e,`, (CASE substream
    WHEN 'f' THEN 'off'
    WHEN 't' THEN 'on'
    WHEN 'p' THEN 'parallel'
   END) AS "%s"
`,"Streaming"):u(e,`, substream AS "%s"
`,"Streaming")),p.sversion>=15e4&&u(e,`, subtwophasestate AS "%s"
, subdisableonerr AS "%s"
`,"Two-phase commit","Disable on error"),p.sversion>=16e4&&u(e,`, suborigin AS "\
%s"
, subpasswordrequired AS "%s"
, subrunasowner AS "%s"
`,"Origin","Password required","Run as owner?"),u(e,`,  subsynccommit AS "%s"
,  subconninfo AS "%s"
`,"Synchronous commit","Conninfo"),p.sversion>=15e4&&u(e,`, subskiplsn AS "%s"
`,"Skip LSN")),o(e,`FROM pg_catalog.pg_subscription
WHERE subdbid = (SELECT oid
                 FROM pg_catalog.pg_database
                 WHERE datname = pg_catalog.current_database())`),!h(e,t,!0,!1,r,
"subname",r,r,r,1)||(o(e,"ORDER BY 1;"),n=await O(e.data),!n)?!1:(l.nullPrint=r,
l.title="List of subscriptions",l.translate_header=!0,l.translate_columns=a,l.n_translate_columns=
J(a),F(n,l,p.queryFout,!1,p.logfile),!0)}function V(t,s){u(t,`pg_catalog.array_t\
o_string(%s, E'\\n') AS "%s"`,s,"Access privileges")}async function Kt(t,s,e){let n={},
l,a=p.popt,i=!1,E=[!1,!1,!1,!1,!1,!1,!1];if(R(n),d(n,`SELECT
  am.amname AS "%s",
  pg_catalog.format_type(c.opcintype, NULL) AS "%s",
  CASE
    WHEN c.opckeytype <> 0 AND c.opckeytype <> c.opcintype
    THEN pg_catalog.format_type(c.opckeytype, NULL)
    ELSE NULL
  END AS "%s",
  CASE
    WHEN pg_catalog.pg_opclass_is_visible(c.oid)
    THEN pg_catalog.format('%%I', c.opcname)
    ELSE pg_catalog.format('%%I.%%I', n.nspname, c.opcname)
  END AS "%s",
  (CASE WHEN c.opcdefault
    THEN '%s'
    ELSE '%s'
  END) AS "%s"`,"AM","Input type","Storage type","Operator class","yes","no","De\
fault?"),e&&u(n,`,
  CASE
    WHEN pg_catalog.pg_opfamily_is_visible(of.oid)
    THEN pg_catalog.format('%%I', of.opfname)
    ELSE pg_catalog.format('%%I.%%I', ofn.nspname, of.opfname)
  END AS "%s",
 pg_catalog.pg_get_userbyid(c.opcowner) AS "%s"
`,"Operator family","Owner"),o(n,`
FROM pg_catalog.pg_opclass c
  LEFT JOIN pg_catalog.pg_am am on am.oid = c.opcmethod
  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.opcnamespace
  LEFT JOIN pg_catalog.pg_type t ON t.oid = c.opcintype
  LEFT JOIN pg_catalog.pg_namespace tn ON tn.oid = t.typnamespace
`),e&&o(n,`  LEFT JOIN pg_catalog.pg_opfamily of ON of.oid = c.opcfamily
  LEFT JOIN pg_catalog.pg_namespace ofn ON ofn.oid = of.opfnamespace
`),t){if(i={value:i},!h(n,t,!1,!1,r,"am.amname",r,r,i,1))return!1;i=i.value}return s&&
!h(n,s,i,!1,"tn.nspname","t.typname","pg_catalog.format_type(t.oid, NULL)","pg_c\
atalog.pg_type_is_visible(t.oid)",r,3)||(o(n,"ORDER BY 1, 2, 4;"),l=await O(n.data),
!l)?!1:(a.nullPrint=r,a.title="List of operator classes",a.translate_header=!0,a.
translate_columns=E,a.n_translate_columns=J(E),F(l,a,p.queryFout,!1,p.logfile),!0)}
async function Xt(t,s,e){let n={},l,a=p.popt,i=!1,E=[!1,!1,!1,!1];if(R(n),d(n,`S\
ELECT
  am.amname AS "%s",
  CASE
    WHEN pg_catalog.pg_opfamily_is_visible(f.oid)
    THEN pg_catalog.format('%%I', f.opfname)
    ELSE pg_catalog.format('%%I.%%I', n.nspname, f.opfname)
  END AS "%s",
  (SELECT
     pg_catalog.string_agg(pg_catalog.format_type(oc.opcintype, NULL), ', ')
   FROM pg_catalog.pg_opclass oc
   WHERE oc.opcfamily = f.oid) "%s"`,"AM","Operator family","Applicable types"),
e&&u(n,`,
  pg_catalog.pg_get_userbyid(f.opfowner) AS "%s"
`,"Owner"),o(n,`
FROM pg_catalog.pg_opfamily f
  LEFT JOIN pg_catalog.pg_am am on am.oid = f.opfmethod
  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = f.opfnamespace
`),t){if(i={value:i},!h(n,t,!1,!1,r,"am.amname",r,r,i,1))return!1;i=i.value}if(s){
if(u(n,`  %s EXISTS (
    SELECT 1
    FROM pg_catalog.pg_type t
    JOIN pg_catalog.pg_opclass oc ON oc.opcintype = t.oid
    LEFT JOIN pg_catalog.pg_namespace tn ON tn.oid = t.typnamespace
    WHERE oc.opcfamily = f.oid
`,i?"AND":"WHERE"),!h(n,s,!0,!1,"tn.nspname","t.typname","pg_catalog.format_type\
(t.oid, NULL)","pg_catalog.pg_type_is_visible(t.oid)",r,3))return!1;o(n,`  )
`)}return o(n,"ORDER BY 1, 2;"),l=await O(n.data),l?(a.nullPrint=r,a.title="List\
 of operator families",a.translate_header=!0,a.translate_columns=E,a.n_translate_columns=
J(E),F(l,a,p.queryFout,!1,p.logfile),!0):!1}async function Zt(t,s,e){let n={},l,
a=p.popt,i=!1,E=[!1,!1,!1,!1,!1,!1];if(R(n),d(n,`SELECT
  am.amname AS "%s",
  CASE
    WHEN pg_catalog.pg_opfamily_is_visible(of.oid)
    THEN pg_catalog.format('%%I', of.opfname)
    ELSE pg_catalog.format('%%I.%%I', nsf.nspname, of.opfname)
  END AS "%s",
  o.amopopr::pg_catalog.regoperator AS "%s"
,  o.amopstrategy AS "%s",
  CASE o.amoppurpose
    WHEN 'o' THEN '%s'
    WHEN 's' THEN '%s'
  END AS "%s"
`,"AM","Operator family","Operator","Strategy","ordering","search","Purpose"),e&&
u(n,`, ofs.opfname AS "%s"
`,"Sort opfamily"),o(n,`FROM pg_catalog.pg_amop o
  LEFT JOIN pg_catalog.pg_opfamily of ON of.oid = o.amopfamily
  LEFT JOIN pg_catalog.pg_am am ON am.oid = of.opfmethod AND am.oid = o.amopmeth\
od
  LEFT JOIN pg_catalog.pg_namespace nsf ON of.opfnamespace = nsf.oid
`),e&&o(n,`  LEFT JOIN pg_catalog.pg_opfamily ofs ON ofs.oid = o.amopsortfamily
`),t){if(i={value:i},!h(n,t,!1,!1,r,"am.amname",r,r,i,1))return!1;i=i.value}return s&&
!h(n,s,i,!1,"nsf.nspname","of.opfname",r,r,r,3)||(o(n,`ORDER BY 1, 2,
  o.amoplefttype = o.amoprighttype DESC,
  pg_catalog.format_type(o.amoplefttype, NULL),
  pg_catalog.format_type(o.amoprighttype, NULL),
  o.amopstrategy;`),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title="List of ope\
rators of operator families",a.translate_header=!0,a.translate_columns=E,a.n_translate_columns=
J(E),F(l,a,p.queryFout,!1,p.logfile),!0)}async function en(t,s,e){let n={},l,a=p.
popt,i=!1,E=[!1,!1,!1,!1,!1,!1];if(R(n),d(n,`SELECT
  am.amname AS "%s",
  CASE
    WHEN pg_catalog.pg_opfamily_is_visible(of.oid)
    THEN pg_catalog.format('%%I', of.opfname)
    ELSE pg_catalog.format('%%I.%%I', ns.nspname, of.opfname)
  END AS "%s",
  pg_catalog.format_type(ap.amproclefttype, NULL) AS "%s",
  pg_catalog.format_type(ap.amprocrighttype, NULL) AS "%s",
  ap.amprocnum AS "%s"
`,"AM","Operator family","Registered left type","Registered right type","Number"),
e?u(n,`, ap.amproc::pg_catalog.regprocedure AS "%s"
`,"Function"):u(n,`, p.proname AS "%s"
`,"Function"),o(n,`FROM pg_catalog.pg_amproc ap
  LEFT JOIN pg_catalog.pg_opfamily of ON of.oid = ap.amprocfamily
  LEFT JOIN pg_catalog.pg_am am ON am.oid = of.opfmethod
  LEFT JOIN pg_catalog.pg_namespace ns ON of.opfnamespace = ns.oid
  LEFT JOIN pg_catalog.pg_proc p ON ap.amproc = p.oid
`),t){if(i={value:i},!h(n,t,!1,!1,r,"am.amname",r,r,i,1))return!1;i=i.value}return s&&
!h(n,s,i,!1,"ns.nspname","of.opfname",r,r,r,3)||(o(n,`ORDER BY 1, 2,
  ap.amproclefttype = ap.amprocrighttype DESC,
  3, 4, 5;`),l=await O(n.data),!l)?!1:(a.nullPrint=r,a.title="List of support fu\
nctions of operator families",a.translate_header=!0,a.translate_columns=E,a.n_translate_columns=
J(E),F(l,a,p.queryFout,!1,p.logfile),!0)}async function an(t){let s={},e,n=p.popt;
return R(s),d(s,`SELECT oid as "%s",
  pg_catalog.pg_get_userbyid(lomowner) as "%s",
  `,"ID","Owner"),t&&(V(s,"lomacl"),o(s,`,
  `)),u(s,`pg_catalog.obj_description(oid, 'pg_largeobject') as "%s"
FROM pg_catalog.pg_largeobject_metadata
ORDER BY oid`,"Description"),e=await O(s.data),e?(n.nullPrint=r,n.title="Large o\
bjects",n.translate_header=!0,F(e,n,p.queryFout,!1,p.logfile),!0):!1}
